#!/bin/bash
# Source: https://github.com/cadorn/bash.origin
# License: http://unlicense.org/
function init {

	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] args: $@"
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] which bash: $(which bash)"
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] bash --version: $(bash --version)"

	if [ ! -z "$BO_LOADED" ]; then
			# If we loaded before we do not load again.
			[ -z "$BO_VERBOSE" ] || echo "[bash.origin] Skip due to BO_LOADED=1"
			return;
	fi

	if ! which perl > /dev/null; then
			echo -e "[BO] ERROR: You must have 'perl' installed!\n"
			exit 1
	fi

	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] SHELL: $SHELL"
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] $SHELL --version: $($SHELL --version)"

	# If 'SHELL' is set to 'bash' that is good enough for us.
	if [ "$(echo "$SHELL" | perl -pe 's/^.*(bash)$/$1/')" != "bash" ]; then
			[ -z "$BO_VERBOSE" ] || echo "[bash.origin] SHELL is not 'bash': $SHELL"
			# 'SHELL' is not what we need so we try and verify that we are running in `bash`
			# by looking for `bash` in the process description.
			# TODO: Use additional ways to detect if we are running in bash.
			set +e
			local __BO_SHELL="$(ps | perl -pe "s/^\s*$$\s+.*?(bash).*?$/\$1/" | grep '^bash$')"
			set -e
			#if [ "$(ps -p $$ | tail -1 | awk '{ print $4 }' | perl -pe 's/^.*(bash)$/$1/')" != "bash" ]; then
			if [ "$__BO_SHELL" != "bash" ]; then
					echo -e "[BO] WARNING: Your 'SHELL' environment variable is set to '$SHELL' while it should be set to '**/bash'\n"
					echo -e "[BO] ERROR: You must be using the 'bash' shell interpreter!\n"
					echo -e "[BO] ACTION: Enter the bash shell for this session only first by running:\n"
					echo -e "             SHELL=/bin/bash /bin/bash\n"
					echo -e "[BO] ACTION: or change your default shell to the bash shell by running:\n"
					echo -e "             sudo dscl localhost -change /Local/Default/Users/$USER UserShell $(which zsh) /bin/bash"
					echo -e "             # Now open a new terminal\n"
					exit 1
			fi
	fi

	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] BO_BASH_ALLOW_3: $BO_BASH_ALLOW_3"

	if [[ $BO_BASH_ALLOW_3 != 1 ]] && [[ "$($SHELL --version)" != "GNU bash, version 4."* ]]; then
			if [ "$(which bash)" != "$SHELL" ]; then
					if [[ "$(bash --version)" == "GNU bash, version 4."* ]]; then
							# We update the SHELL to where 'bash' actually is.
							SHELL="$(which bash)"
					else
							echo -e "[BO] ERROR: You are using bash version '$($SHELL --version)' instead of version 4!\n"
							echo -e "[BO] ACTION: Install bash version 4. On OSX you can use:\n"
							echo -e "             brew install bash\n"
							echo -e "[BO] ACTION: Then call your script again using:\n"
							echo -e "             SHELL=/usr/local/bin/bash /usr/local/bin/bash <ScriptPath>\n"
							echo -e "[BO] ACTION: or change your default shell to the bash shell by running:\n"
							echo -e "             sudo dscl localhost -change /Local/Default/Users/$USER UserShell $(which zsh) /bin/bash"
							echo -e "             # Now open a new terminal\n"
							exit 1
					fi
			fi
	fi


	if [ -z "$ORIGINAL_BO_CLI_ARGS" ]; then
			export ORIGINAL_BO_CLI_ARGS="$@"
	fi
	local ORIGINAL_BO_ROOT_SCRIPT_PATH="$BO_ROOT_SCRIPT_PATH"
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] ORIGINAL_BO_CLI_ARGS: $ORIGINAL_BO_CLI_ARGS"
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] ORIGINAL_BO_ROOT_SCRIPT_PATH: $ORIGINAL_BO_ROOT_SCRIPT_PATH"


	###############################
	# Declare Boot Globals
	###############################

	BO_LOG_PREFIX="[BO] "
	BO_READ_SELF_BASH_SOURCE="$""{BASH_SOURCE[0]:-$""0}"


	###############################
	# Declare Boot Functions
	###############################

	function BO_log {
		if [ "$1" != "1" ]; then
			return;
		fi
		echo -e "${*:2}"
	}

	function BO_exit_error {
			echo >&2 "$(BO_cecho "ERROR: $1" RED BOLD)"
			exit 1
	}

	function BO_ensure_env_HOME {
		# Should fail if not set or set to empty string.
		if [ ! -n "${HOME}" ] || [ "${HOME}" == "" ]; then
			echo "[BO] ERROR: 'HOME' environment variable is not set! Used by: $1"
			exit 1
		fi
	}

	function BO_setResult {
		local  __resultvar=$1
	    eval $__resultvar="'$2'"
		return 0
	}

	function BO_deriveSelfDir {
		# @source http://stackoverflow.com/a/246128/330439
		local SOURCE="$2"
		local DIR=""
		while [ -h "$SOURCE" ]; do
		  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		  SOURCE="$(readlink "$SOURCE")"
		  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
		done
		BO_setResult $1 "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		return 0
	}

	function BO_sourceProfile {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] args: $@"
		if [[ $BO_ENABLE_SOURCE_PROFILE == 0 ]]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] return due to 'BO_ENABLE_SOURCE_PROFILE == 0'"
			return 0
		fi
		if [ ! -z "$CIRCLE_SHA1" ]; then
			# On circleci we do not load the profile again
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] return due to 'CIRCLE_SHA1' set"
			return 0
		fi
		# TODO: Allow sourcing multiple times if 'force' argument provided.
		if [ -z "$BO_sourceProfile__sourced" ]; then
			export BO_sourceProfile__sourced="1"
			BO_ensure_env_HOME "BO_sourceProfile"
			local currentDirectory="$(pwd)"
			local currentPATH="$PATH"
			local currentNVM=`printenv | grep '^NVM_'`
			if [ -f "$HOME/.bash_profile" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Source from '$HOME/.bash_profile' (pwd: ${currentDirectory})"
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						. "$HOME/.bash_profile" >/dev/null 2>&1
				else
						. "$HOME/.bash_profile"
				fi
				set -e
			elif [ -f "$HOME/.profile" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Source from '$HOME/.profile' (pwd: ${currentDirectory})"
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						. "$HOME/.profile" >/dev/null 2>&1
				else
						. "$HOME/.profile"
				fi
				set -e
			fi
			if [ "$(pwd)" != "${currentDirectory}" ]; then
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Changing directory back to '${currentDirectory}' (pwd: $(pwd))"
					cd "${currentDirectory}"
			fi
			export PATH="${currentPATH}"
			eval "$currentNVM"
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] DONE"
	}

	function BO_has_cli_arg {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] args: $@"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] ORIGINAL_BO_CLI_ARGS: $ORIGINAL_BO_CLI_ARGS"
			if echo "$ORIGINAL_BO_CLI_ARGS" | grep -q -Ee "\s*$1\s*"; then
					return 0
			fi
			if echo "$npm_config_argv" | grep -q -Ee '"$1"'; then
					return 0
			fi
			return 1
	}

	function BO_checkVerbose {
		local _VERBOSE="$VERBOSE"
		# Look for '-v', '--verbose', '-d' or '--debug' flags.
		if echo "$@" | grep -q -Ee '(\$|\s*)--?([vd]|verbose|debug)(\s*|\$)'; then
		    _VERBOSE="1"
		fi
		if echo "$npm_config_argv" | grep -q -Ee '"--?([vd]|verbose|debug)"'; then
		    _VERBOSE="1"
		fi
#		if [ "$_VERBOSE" == "1" ]; then
#			BO_log "$_VERBOSE" "[BO_checkVerbose] Verbose Enabled: $_VERBOSE"
#		fi
		BO_setResult "$1" "$_VERBOSE"
	}

	function BO_resetLoaded {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_resetLoaded]"
			export BO_LOADED=
			export BO_IS_SOURCING=
			export BO_sourceProfile__sourced=
	}

	###############################
	# Boot self
	###############################

	# NOTE: We no longer source the profile automatically!
	if [ -z "$BO_ENABLE_SOURCE_PROFILE" ]; then
		BO_ENABLE_SOURCE_PROFILE=0;
	fi
	BO_sourceProfile

	eval BO_SELF_BASH_SOURCE="$BO_READ_SELF_BASH_SOURCE"
	BO_deriveSelfDir ___TMP___ "$BO_SELF_BASH_SOURCE"
	local BO_DIR="$___TMP___"

	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] BO_DIR: $BO_DIR"

	BO_checkVerbose "VERBOSE" "$@"
	export VERBOSE
	export BO_VERBOSE

	[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[bash.origin] BO_VERBOSE: ${BO_VERBOSE}"
	[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[bash.origin] VERBOSE: ${VERBOSE}"

	export BO_LOADED=1

	# NOTE: Variables starting with '_BO_' are for primarily internal use
	#       and should not be set externally other than to force a specific
	#       internal state for debugging purposes.
	if [ -z "$_BO_OPTIMIZED" ]; then
		# If not set we set it based on BO_VERBOSE.
		if [ -z "$BO_VERBOSE" ]; then
				export _BO_OPTIMIZED=1
		else
				export _BO_OPTIMIZED=0
		fi
	fi

	if echo "$@" | grep -q -Ee '(\$|\s*)--compile(\s*|\$)'; then
			export _BO_OPTIMIZED=0
	elif echo "$npm_config_argv" | grep -q -Ee '"--compile"'; then
			export _BO_OPTIMIZED=0
	fi


	###############################
	# Delegate if requested
	###############################

	if [ "$BO_ROOT_SCRIPT_PATH" != "" ]; then
		if [ "$1" != "BO" ]; then
			if [ "$2" != "install" ]; then
				if [ -e "$BO_ROOT_SCRIPT_PATH" ]; then
					local ORIGINAL_BO_ROOT_SCRIPT_DIR
					BO_deriveSelfDir ORIGINAL_BO_ROOT_SCRIPT_DIR "$BO_ROOT_SCRIPT_PATH"
					if [ "$BO_DIR" != "$ORIGINAL_BO_ROOT_SCRIPT_DIR" ]; then
						[ -z "$BO_VERBOSE" ] || echo "[bash.origin] Delegate to BO_ROOT_SCRIPT_PATH: $BO_ROOT_SCRIPT_PATH"
						# Delegate to the Bash.Origin script at 'BO_ROOT_SCRIPT_PATH'
						# which was set before calling us.
						export BO_LOADED=
						. "$BO_ROOT_SCRIPT_PATH"
						return;
					fi
				else
					BO_ensure_env_HOME "Delegate to BO_ROOT_SCRIPT_PATH"
					if [ "$BO_ROOT_SCRIPT_PATH" != "$HOME/.bash.origin" ]; then
						echo "[bash.origin] ERROR: 'BO_ROOT_SCRIPT_PATH' ($BO_ROOT_SCRIPT_PATH) not found!"
						exit 1
					fi
				fi
			fi
		fi
	else
		if [ -e "$BO_DIR/bash.origin" ]; then
			BO_ROOT_SCRIPT_PATH="$BO_DIR/bash.origin"
		elif [ -e "$BO_DIR/.bash.origin" ]; then
			BO_ROOT_SCRIPT_PATH="$BO_DIR/.bash.origin"
		else
			BO_ensure_env_HOME "Use default .bash.origin"
			BO_ROOT_SCRIPT_PATH="$HOME/.bash.origin"
		fi
	fi

	export BO_ROOT_SCRIPT_PATH
	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] BO_ROOT_SCRIPT_PATH: $BO_ROOT_SCRIPT_PATH"

	###############################
	# Declare Globals
	###############################

	if [ "$BO_IS_SOURCING" == "1" ]; then
		__ON_INIT__BO_IS_SOURCING="1"
	else
		__ON_INIT__BO_IS_SOURCING="0"
	fi

	BO_ROOT_SOURCE_URL="https://raw.githubusercontent.com/bash-origin/bash.origin/master/bash.origin"
	if [ -z "$BO_GLOBAL_SYSTEM_CACHE_DIR" ]; then
		BO_ensure_env_HOME "Use default .bash.origin.cache"
		BO_GLOBAL_SYSTEM_CACHE_DIR="$HOME/.bash.origin.cache"
	fi
	export BO_GLOBAL_SYSTEM_CACHE_DIR
	if [ -z "$BO_SYSTEM_CACHE_DIR" ]; then
		BO_SYSTEM_CACHE_DIR="$BO_GLOBAL_SYSTEM_CACHE_DIR"
	fi
	export BO_SYSTEM_CACHE_DIR

	if [ -z "$BO_VERSION_RECENT_NODE" ]; then
		BO_VERSION_RECENT_NODE="5"
	fi
	if [ -z "$BO_VERSION_NVM" ]; then
		BO_VERSION_NVM="0.31.1"
	fi
	if [ -z "$BO_VERSION_NVM_NODE" ]; then
		BO_VERSION_NVM_NODE="5"
	fi
	if [ -z "$BO_VERSION_NVM_IOJS" ]; then
		# DEPRECATED
		BO_VERSION_NVM_IOJS="iojs-v3.0.0"
	fi
	if [ -z "$BO_VERSION_SMI_CLI" ]; then
		BO_VERSION_SMI_CLI="0.35.14"
	fi

	[ -z "$BO_VERBOSE" ] || echo "[bash.origin] BO_GLOBAL_SYSTEM_CACHE_DIR: $BO_GLOBAL_SYSTEM_CACHE_DIR"


	###############################
	# Declare Utility Functions
	###############################

	function BO_now {
			BO_setResult "$1" "$(date +%s)"
	}

	function BO_format {
		if [ "$1" != "1" ]; then
			return;
		fi
		if [ "$2" == "HEADER" ]; then
			echo "##################################################";
			echo "# $3";
			echo "##################################################";
		fi
		if [ "$2" == "FOOTER" ]; then
			echo "##################################################";
			echo ""
		fi
	}

	function BO_hash {
			echo -n "yourpassword" | openssl sha1
	}

	function BO_replace {
			echo -n "$(echo "$1" | perl -pe "s/$2/\$1/")"
	}

	function BO_test {
			if [ "$(echo "$1" | perl -wnE "say for /($2)/")" == "" ]; then
					return 1
			fi
			return 0
	}

	function BO_ensure_parent_dir {
			if [ ! -e "$(dirname "$1")" ]; then
					mkdir -p "$(dirname "$1")"
			fi
	}


	if echo "$@" | grep -q -Ee '(\$|\s*)--install-only(\s*|\$)'; then
			BO_FLAG_INSTALL_ONLY=1
	elif echo "$npm_config_argv" | grep -q -Ee '"--install-only"'; then
			BO_FLAG_INSTALL_ONLY=1
	fi

	function BO_exit_if_install_only {
			onExitFunc="$1"
			function doExit {
					if [ ! -z "$onExitFunc" ]; then
							"$onExitFunc"
					fi
			    exit 0
			}
			if [[ $BO_FLAG_INSTALL_ONLY == 1 ]]; then
					doExit
			elif echo "$@" | grep -q -Ee '(\$|\s*)--install-only(\s*|\$)'; then
					doExit
			elif echo "$npm_config_argv" | grep -q -Ee '"--install-only"'; then
					doExit
			fi
	}


	function BO_has {
	  type "$1" > /dev/null 2>&1
	}

	function BO_sudo {
		# TODO: Detect if we even need to ask for sudo. If not just run command.
		local NEED_TO_ASK="1"
		if [ "$NEED_TO_ASK" == "1" ]; then
			echo "$BO_LOG_PREFIX""WARNING: Asking for sudo access to run: $1"
		fi
		sudo $1
	}

	function BO_compileModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] args: $@"
			# TODO: Resolve './' and aliased paths based on mappings.
			local _raw_module_source_path="$2"
			local _compiled_module_source_path="$2~.compiled.bash"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] _raw_module_source_path: $(stat -f "%m%t%Sm %N" $_raw_module_source_path)"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] _compiled_module_source_path: $(stat -f "%m%t%Sm %N" $_compiled_module_source_path) 2> /dev/null"
			# If source file is newer than compiled file
			# TODO: Compile if 'bash.origin.modules' plugin implementation directory is newer than compiled module.
			if [ ! -e "${_compiled_module_source_path}" ] || [ $_BO_OPTIMIZED == 0 ] || [ ${_raw_module_source_path} -nt ${_compiled_module_source_path} ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] Compile source '${_raw_module_source_path}' to '${_compiled_module_source_path}' (pwd: $(pwd), _BO_OPTIMIZED: $_BO_OPTIMIZED)"
    			BO_callPlugin "bash.origin.modules" compile ${_raw_module_source_path} ${_compiled_module_source_path}
			else
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] Skip compile as source has not changed."
			fi
			BO_setResult "$1" "${_compiled_module_source_path}"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] DONE"
	}

	function BO_requireModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] args: $@"
			if [[ "${BASH_VERSION}" != "4."* ]]; then
					echo "$BO_LOG_PREFIX""ERROR: You must be using bash version 4 or newer to use 'BO_requireModule'! Put this '#!/usr/bin/env bash' shebang at the top of the script file you are executing to get the 'bash' command from your PATH instead of default for your shell."
					exit 1
			fi
			if [ "$2" != "as" ]; then
						echo "$BO_LOG_PREFIX""ERROR: Second argument to BO_requireModule should be 'as'!"
						exit 1
			fi
			if [[ "${1}" == "."* ]]; then
					# Relative include based on PWD is used from outside a module
					# and based on path of parent module if used from inside module.
					BO_sourceModule "$(pwd)/$1"
			elif [[ "${1}" == "@"* ]]; then

					if [[ "${1}" == "@com.github/"* ]]; then
							local PLUGIN_URI_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									uriParts[1] = uriParts[1].split(".");
									uriParts[1].reverse();
									uriParts[1] = uriParts[1].join(".");
									process.stdout.write(uriParts[1] + "/" + uriParts[2]);
							' "${1}"`
							local PLUGIN_VERSION_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[3]);
							' "${1}"`
							local PLUGIN_PATH_
							BO_ensurePlugin "PLUGIN_PATH_" "$PLUGIN_URI_"
							PLUGIN_PATH_="$(dirname "${PLUGIN_PATH_}")"
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Using ensured plugin path: $PLUGIN_PATH_"
							local PLUGIN_MODULE_NAME_="_#_org.bashorigin_#_${PLUGIN_VERSION_}.sh"
							local PLUGIN_MODULE_PATH_="${PLUGIN_PATH_}/${PLUGIN_MODULE_NAME_}"
							if [ ! -e "$PLUGIN_MODULE_PATH_" ]; then
									echo "$BO_LOG_PREFIX""ERROR: Module '$PLUGIN_MODULE_NAME_' does not exist in plugin at path '$PLUGIN_MODULE_PATH_'!"

									# DEPRECATED
									PLUGIN_MODULE_NAME_="org.bashorigin-${PLUGIN_VERSION_}.sh"
									PLUGIN_MODULE_PATH_="${PLUGIN_PATH_}/${PLUGIN_MODULE_NAME_}"
									if [ ! -e "$PLUGIN_MODULE_PATH_" ]; then
											echo "$BO_LOG_PREFIX""ERROR: Module '$PLUGIN_MODULE_NAME_' does not exist in plugin at path '$PLUGIN_MODULE_PATH_'!"

											exit 1
									fi
							fi
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Load module from plugin: $PLUGIN_MODULE_PATH_"
							BO_sourceModule "$PLUGIN_MODULE_PATH_"
					elif [[ "${1}" == "@/"* ]]; then

							local PLUGIN_PATH_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[1]);
							' "${1}"`
							local PLUGIN_VERSION_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[2]);
							' "${1}"`
							local PLUGIN_MODULE_PATH_="$PLUGIN_PATH_/_#_org.bashorigin_#_${PLUGIN_VERSION_}.sh"
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Load module from plugin: $PLUGIN_MODULE_PATH_"
							BO_sourceModule "$PLUGIN_MODULE_PATH_"
					else
							echo "ERROR: No actor found for URI: ${1}"
							exit 1
					fi
			elif [[ "${1}" == "/"* ]]; then

					local PLUGIN_MODULE_PATH_="${1}"
					BO_sourceModule "$PLUGIN_MODULE_PATH_"

			else
					echo "TODO: Alias-based includes that should resolve via mappings"
					exit 1
			fi
			local func="$2"
			shift
			shift
			"$func" "$@"
	}

	function BO_sourceModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] args: $@"
			local _raw_source_path="$1"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] _raw_source_path: $_raw_source_path"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] pwd: $(pwd)"
			BO_compileModule "_raw_source_path" "${_raw_source_path}"
			BO_sourcePrototype "${_raw_source_path}" ${*:2}
	}

	function BO_sourcePrototype {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] args: $@"
		local _raw_source_path="$1"
		# Check if we have a module extension and if we do compile the module first.
		if [[ "${_raw_source_path}" == *".bo.sh" ]]; then
				BO_compileModule "_raw_source_path" "${_raw_source_path}"
		fi
		# Now load the module
		local _proto_source_path="${_raw_source_path}"
		if [ ! -e "${_proto_source_path}" ]; then
				_proto_source_path="${_proto_source_path}.sh"
				if [ ! -e "${_proto_source_path}" ]; then
						echo "$BO_LOG_PREFIX""ERROR: Cannot source '${_raw_source_path}' nor '${_proto_source_path}'. File not found!"
						[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] DONE:1"
						return 1
				fi
		fi
		local __ON_INIT__BO_IS_SOURCING
		#echo "ENV: `( set -o posix ; set ) | less | grep BO_IS_SOURCING | while read line; do echo "___$line";done`"
		local __PREVIOUS_BO_IS_SOURCING="$BO_IS_SOURCING"
		local __PREVIOUS_BO_LOADED="$BO_LOADED"
		# TODO: Reset all relevant variables.
		BO_IS_SOURCING="1"
		BO_LOADED=1
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] ${_proto_source_path}"
		if [ "${*:2}" == "" ]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] Sourcing '${_proto_source_path}' using call method 1"
			# NOTE: If no arguments specified the source path becomes part of the arguments
			#       so we provide an empty one which fixes this for bash.
		    . "${_proto_source_path}" ""
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] done: Sourcing '${_proto_source_path}' using call method 1"
		else
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] Sourcing '${_proto_source_path}' using call method 2"
		    . "${_proto_source_path}" ${*:2}
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] done: Sourcing '${_proto_source_path}' using call method 2"
		fi
		# TODO: Restore all relevant variables.
		BO_IS_SOURCING="$__PREVIOUS_BO_IS_SOURCING"
		BO_LOADED="$__PREVIOUS_BO_LOADED"
		#while IFS= read -r -d $'\0' line; do
		#    export "$line"
		#done < <(bash -s <<< 'export VARNAME=something; env -0')
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] DONE"
	}

	function BO_followPointer {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "BO_followPointer($1, $2, $3)"

		_POINTER_RESULT_VAR="$1"
		_POINTER_LOOKUP_FILENAME="$3"
		_POINTER_RESOLVED="0"

		function checkPath {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "BO_followPointer:checkPath($1)"
			if [ -d "$1/$_POINTER_LOOKUP_FILENAME" ] || [ -h "$1/$_POINTER_LOOKUP_FILENAME" ]; then
				checkPath "$1/$_POINTER_LOOKUP_FILENAME"
			elif [ -e "$1/$_POINTER_LOOKUP_FILENAME" ]; then
				POINTER_VALUE=`cat $1/$_POINTER_LOOKUP_FILENAME`
				if [ "$POINTER_VALUE" == "." ]; then
					BO_realpath "$_POINTER_RESULT_VAR" "$1"
					_POINTER_RESOLVED="1"
				else
					checkPath "$1/$POINTER_VALUE"
				fi
			fi
		}
		checkPath "$2"
		if [ "$_POINTER_RESOLVED" == "0" ]; then
			echo "ERROR: Could not resolve pointer '$_POINTER_LOOKUP_FILENAME' for path '$2'"
			exit 1;
		fi
	}

	function BO_realpath {
		if BO_has "realpath"; then
			BO_setResult "$1" "$(realpath "$2")"
		else
			# @source http://stackoverflow.com/a/19512992/330439
			function abspath() {
			    # generate absolute path from relative path
			    # $1     : relative filename
			    # return : absolute path
			    if [ -d "$1" ]; then
			        # dir
			        (cd "$1"; pwd)
			    elif [ -f "$1" ]; then
			        # file
			        if [[ $1 == */* ]]; then
			            echo "$(cd "${1%/*}"; pwd)/${1##*/}"
			        else
			            echo "$(pwd)/$1"
			        fi
			    fi
			}
			BO_setResult "$1" "`abspath "$2"`"
		fi
	}

	function BO_isSourced {
		BO_setResult $1 "$__ON_INIT__BO_IS_SOURCING"
	}

	function BO_dedupe_PATH {
		# @source http://unix.stackexchange.com/a/149054
		export PATH="$(echo $PATH | perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, scalar <>))')"
	}

	function BO_strip_PATH {
		local WORK=:$PATH:
		local REMOVE="$1"
		WORK=${WORK/:$REMOVE:/:}
		WORK=${WORK%:}
		WORK=${WORK#:}
		export PATH=$WORK
	}

	function BO_prepend_PATH {
		export PATH="$1:$PATH"
	}

	# @see http://stackoverflow.com/a/29239609/330439
	function BO_if_os {
			local os="$1"
			if [ "$os" == "osx" ]; then
					os="darwin"
			fi
			[[ $OSTYPE == *$os* ]];
	}
	function BO_if_nix {
	    case "$OSTYPE" in
	        *linux*|*hurd*|*msys*|*cygwin*|*sua*|*interix*) sys="gnu";;
	        *bsd*|*darwin*) sys="bsd";;
	        *sunos*|*solaris*|*indiana*|*illumos*|*smartos*) sys="sun";;
	    esac
	    [[ "${sys}" == "$1" ]];
	}

	function BO_ensure_executable {
		if [[ ! -x "$1" ]]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Making path '$1' executable."
			chmod ug+x "$1"
		fi
	}

	function BO_exit_on_error {
		if [[ $? -ne 0 ]] ; then
			echo "FATAL ERROR while running '$*': $1"
		    exit 1
		fi
	}

	function BO_ensure_bo_script_bin {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_bo_script_bin] args: $@"
			# TODO: Store the 'bash.origin.script' file on other bin paths as well.
			if [ ! -z "$NVM_BIN" ]; then
					# Ensure 'bash.origin.script' is at '$NVM_BIN/bash.origin.script'
					if [ ! -e "$NVM_BIN/bash.origin.script" ]; then
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Placing wrapper script for '$BO_ROOT_SCRIPT_PATH' at '$NVM_BIN/bash.origin.script'"
							# TODO: Dynamically feed based on 'BO_resetLoaded'
							echo -e "#!/usr/bin/env bash\nBO_LOADED=\nBO_IS_SOURCING=\nBO_sourceProfile__sourced=\n. $BO_ROOT_SCRIPT_PATH BOS $""@" > "$NVM_BIN/bash.origin.script"
							chmod u+x "$NVM_BIN/bash.origin.script"
					fi
					# Ensure 'bash.origin' is at '$NVM_BIN/bash.origin'
					if [ ! -e "$NVM_BIN/bash.origin" ]; then
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Placing wrapper script for '$BO_ROOT_SCRIPT_PATH' at '$NVM_BIN/bash.origin'"
							# TODO: Dynamically feed based on 'BO_resetLoaded'
							echo -e "#!/usr/bin/env bash\nBO_LOADED=\nBO_IS_SOURCING=\nBO_sourceProfile__sourced=\n. $BO_ROOT_SCRIPT_PATH BOB $""@" > "$NVM_BIN/bash.origin"
							chmod u+x "$NVM_BIN/bash.origin"
					fi
			fi
	}

	function BO_ensure_recent_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] args: $@"
		# We just care that a version of NodeJS later than BO_VERSION_RECENT_NODE is installed.
		set +e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] Existing NodeJS version: $(node --version 2>&1 || true) ($(which node))"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] Desired NodeJS version: v5"
		if [[ "$(node --version 2>&1 | perl -pe 's/^v(\d+).+$/$1/')" -ge $BO_VERSION_RECENT_NODE ]]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] found"
			BO_ensure_bo_script_bin
			return
		fi
		set -e
		BO_ensure_node "$@"		
	}

	function BO_ensure_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] args: $@"
		set +e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Existing NodeJS version: $(node --version 2>&1 || true) ($(which node))"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Desired NodeJS version: v${BO_VERSION_NVM_NODE}"
		if [ "$(node --version 2>&1 | perl -pe 's/^v(\d+).+$/$1/')" == "${BO_VERSION_NVM_NODE}" ]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE:1"
			BO_ensure_bo_script_bin
			return
		fi
		set -e
		BO_sourceProfile
		set +e
		if [ "$(node --version 2>&1 | perl -pe 's/^v(\d+).+$/$1/')" == "${BO_VERSION_NVM_NODE}" ]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE:2"
			BO_ensure_bo_script_bin
			return
		fi
		set -e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] PATH: ${PATH}"
		if [ -e "/usr/bin" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] 'ls /usr/bin': $(ls /usr/bin | grep node)"
		fi
		BO_ensure_nvm
		function installAndUse {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Installing and activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
			# TODO: Detect if error checking was enabled before disabeling
			# @see http://mywiki.wooledge.org/BashFAQ/105
			set +e
			nvm install "$BO_VERSION_NVM_NODE"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Deleting prefix for NodeJS version $BO_VERSION_NVM_NODE using nvm."
			nvm use --delete-prefix "${BO_VERSION_NVM_NODE}" > /dev/null 2>&1
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Installing and activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
		}
		# If major version matches we do not activate.
		if ! BO_has node || [ "$(echo "$(node --version)" | perl -pe 's/^v(\d+)\..+$/$1/')" != "$BO_VERSION_NVM_NODE" ] ; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
			set +e
			nvm use --delete-prefix "${BO_VERSION_NVM_NODE}" > /dev/null 2>&1 || installAndUse
			set -e
			#result=$((nvm use --delete-prefix "${BO_VERSION_NVM_NODE}") 2>&1)
			#echo "RESULT: $result"
			#echo "CODE: $?"
			#if [[ ${result} == *"npm config delete prefix"* ]]; then
			#	cmd=$(echo "${result}" | grep "nvm use --delete-prefix ${BO_VERSION_NVM_NODE}" | perl -pe 's/^.*(nvm use --delete-prefix [^`]+)`.*$/$1/')
			#	if [ ! -z "${cmd}" ]; then
			#		$cmd
			#	    npm --prefix="" set prefix ""
			#		npm config set prefix ""
			#	fi
			#fi
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
		fi
		# TODO: Do not set default if already set.
		if [ "${1}" == "default" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Setting NodeJS version $BO_VERSION_NVM_NODE as default."
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						nvm alias default node > /dev/null 2>&1
				else
						nvm alias default node
				fi
				set -e
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Setting NodeJS version $BO_VERSION_NVM_NODE as default."
   		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] which node: $(which node)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] ls -al $(which node): ls -al $(which node)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] node --version: $(node --version > /dev/null 2>&1 || true)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE"
	}

	# DEPRECATED
	function BO_ensure_iojs {
# TODO: Check if 'node' command corresponds to our version
#		if BO_has "node"; then
#			return
#		fi
#		BO_sourceProfile
#		if BO_has "node"; then
#			return
#		fi
		BO_ensure_nvm
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Activating IO.JS version $BO_VERSION_NVM_IOJS using nvm."
		if [ -z "$BO_VERBOSE" ]; then
				nvm use "$BO_VERSION_NVM_IOJS" > /dev/null 2>&1
		else
				nvm use "$BO_VERSION_NVM_IOJS"
		fi
		if [[ $? -ne 0 ]]; then
				nvm install "$BO_VERSION_NVM_IOJS"
				nvm use "$BO_VERSION_NVM_IOJS"
		fi
	}

	function BO_ensure_nvm {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_nvm] args: $@"
		# @see https://github.com/creationix/nvm
		BO_ensureInSystemCache "NVM_PATH_" "github.com/creationix/nvm" "$BO_VERSION_NVM" "https://github.com/creationix/nvm/archive/v$BO_VERSION_NVM.tar.gz"
		pushd "$NVM_PATH_" > /dev/null
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Loading nvm from '$NVM_PATH_/nvm.sh'"
			export NVM_EXEC_PATH="$NVM_PATH_/nvm-exec"
			set +e
			if [ -z "$BO_VERBOSE" ]; then
					. "$NVM_PATH_/nvm.sh" >/dev/null 2>&1
			else
					. "$NVM_PATH_/nvm.sh"
			fi
			set -e
		popd > /dev/null
		BO_ensure_bo_script_bin
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_nvm] DONE"
#		curl \
#		    -H "Pragma: no-cache, must-revalidate" \
#		    -H "Cache-Control: no-cache, must revalidate" \
#		    "https://raw.githubusercontent.com/creationix/nvm/v$BO_VERSION_NVM/install.sh" \
#		    | sh
#		BO_sourceProfile
	}

	function BO_link_node {
		rm -f "$1/node" > /dev/null 2>&1 || true
		BO_ensure_node
		ln -s "$NVM_BIN/node" "$1/node"
	}

	function BO_link_npm {
		rm -f "$1/npm" > /dev/null 2>&1 || true
		BO_ensure_node
		ln -s "$NVM_BIN/npm" "$1/npm"
	}

	function BO_run_silent_node {
		local __OLD_BO_VERBOSE="${BO_VERBOSE}"
		local __OLD_VERBOSE="${VERBOSE}"
		BO_VERBOSE=
		VERBOSE=
		BO_run_recent_node "$@"
		BO_VERBOSE="${__OLD_BO_VERBOSE}"
		VERBOSE="${__OLD_VERBOSE}"
	}

	function BO_run_recent_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] args: $@"
		BO_ensure_recent_node
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] NodeJS version: $(node --version 2>&1)"
		node "$@"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] END"
	}

	function BO_run_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] args: $@"
		BO_ensure_node
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] NodeJS version: $(node --version 2>&1)"
		node "$@"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] END"
	}

	# DEPRECATED
	function BO_run_iojs {
		BO_ensure_iojs
		node $@
	}

	function BO_run_npm {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] args: $@"
		BO_ensure_node
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] NodeJS version: $(node --version)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] npm version: $(npm --version)"
		npm $@
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] END"
	}

	function BO_ensure_smi {
		BO_ensure_node
		local CACHED_PATH
		BO_isInSystemCache CACHED_PATH "github.com/sourcemint/smi" "$BO_VERSION_SMI_CLI"
		if [ "$CACHED_PATH" == "" ]; then
			# TODO: Ask user before installing.
			echo "$BO_LOG_PREFIX""Installing smi ..."
			BO_ensureInSystemCache "DOWNLOADED_PATH" "github.com/sourcemint/smi" "$BO_VERSION_SMI_CLI" "https://github.com/sourcemint/smi/archive/v$BO_VERSION_SMI_CLI.tar.gz"
			# TODO: Install into "$DOWNLOADED_PATH.`now`" and only rename on success.
			# TODO: Stop this from also being written to stdout.
			pushd "$DOWNLOADED_PATH" > /dev/null
				BO_run_npm install --production
			popd > /dev/null
			echo "$BO_LOG_PREFIX""... smi installed"
			CACHED_PATH="$DOWNLOADED_PATH"
		fi
		BO_setResult $1 "$CACHED_PATH"
	}

	function BO_link_smi {
		rm -f "$1/smi" > /dev/null 2>&1 || true
		local SMI_CACHE_PATH_
		BO_ensure_smi SMI_CACHE_PATH_
		ln -s "$SMI_CACHE_PATH_/bin/smi" "$1/smi"
	}

	function BO_run_smi {
		local SMI_CACHE_PATH_
		BO_ensure_smi SMI_CACHE_PATH_
		"$SMI_CACHE_PATH_/bin/smi" $@
	}

	function BO_systemCachePath {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] args: $@"
		local URI_DIRNAME_=`echo "$2" | sed 's/\//~/g'`
		local URI_MAJOR_VERSION_=`echo "$3" | perl -wnE 'say for /^\d+/g'`
		local DOWNLOAD_PATH_="$BO_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/installed/master"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (1): $DOWNLOAD_PATH_"
		if [ -d "$DOWNLOAD_PATH_" ]; then
			BO_setResult $1 "$DOWNLOAD_PATH_"
		else
			DOWNLOAD_PATH_="$BO_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/snapshot/$3"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (2): $DOWNLOAD_PATH_"
		  	local DOWNLOAD_DIR_="$( dirname "$DOWNLOAD_PATH_")"
		  	if [ "$4" != "nocreate" ]; then
			  	if [ ! -d "$DOWNLOAD_DIR_" ]; then
					mkdir -p "$DOWNLOAD_DIR_"
			  	fi
			fi
			BO_setResult $1 "$DOWNLOAD_PATH_"
		fi
	}

	function BO_globalSystemCachePath {
		local URI_DIRNAME_=`echo "$2" | sed 's/\//~/g'`
		local URI_MAJOR_VERSION_=`echo "$3" | perl -wnE 'say for /^\d+/g'`
		local DOWNLOAD_PATH_="$BO_GLOBAL_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/installed/master"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_globalSystemCachePath] Check path (1): $DOWNLOAD_PATH_"
		if [ -d "$DOWNLOAD_PATH_" ]; then
			BO_setResult $1 "$DOWNLOAD_PATH_"
		else
			DOWNLOAD_PATH_="$BO_GLOBAL_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/snapshot/$3"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_globalSystemCachePath] Check path (2): $DOWNLOAD_PATH_"
		  	local DOWNLOAD_DIR_="$( dirname "$DOWNLOAD_PATH_")"
		  	if [ "$4" != "nocreate" ]; then
			  	if [ ! -d "$DOWNLOAD_DIR_" ]; then
					mkdir -p "$DOWNLOAD_DIR_"
			  	fi
			fi
			BO_setResult $1 "$DOWNLOAD_PATH_"
		fi
	}

	function BO_isInSystemCache {
		local CACHE_PATH__
		BO_systemCachePath CACHE_PATH__ "$2" "$3" "nocreate"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_isInSystemCache] for uri '$2' at revision '$3': $CACHE_PATH__"
		if [ -e "$CACHE_PATH__" ]; then
			BO_setResult $1 "$CACHE_PATH__"
		else
			BO_setResult $1 ""
		fi
	}

	function BO_isInGlobalSystemCachePath {
		local CACHE_PATH__
		BO_globalSystemCachePath CACHE_PATH__ "$2" "$3" "nocreate"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_isInGlobalSystemCachePath] for uri '$2' at revision '$3': $CACHE_PATH__"
		if [ -e "$CACHE_PATH__" ]; then
			BO_setResult $1 "$CACHE_PATH__"
		else
			BO_setResult $1 ""
		fi
	}

	function BO_downloadToSystemCache {
		local DOWNLOAD_PATH__
		BO_systemCachePath DOWNLOAD_PATH__ "$2" "$3"
		local DOWNLOAD_URL_="$4"
		local DOWNLOAD_FILE_EXTENSION_=`echo "$DOWNLOAD_URL_" | perl -wnE 'say for /\.([^\.]+)$/g'`
		# TODO: Append '?t=$(date +%s)' to URL to force download?
	  	function download {
			if BO_has "curl"; then
				curl \
				    -L \
				    -H "Pragma: no-cache, must-revalidate" \
				    -H "Cache-Control: no-cache, must revalidate" \
				    $*
			elif BO_has "wget"; then
				# Emulate curl with wget
				# @source https://github.com/creationix/nvm/blob/master/install.sh
				# TODO: Add nocache flag.
				local ARGS=$(echo "$*" | command sed -e 's/--progress-bar /--progress=bar /' \
					-e 's/-L //' \
					-e 's/-I /--server-response /' \
					-e 's/-s /-q /' \
					-e 's/-o /-O /' \
					-e 's/-C - /-c /')
				wget $ARGS
			fi
	  	}
	  	local ARCHIVE_DOWNLOAD_PATH__
	  	if [ "$DOWNLOAD_FILE_EXTENSION_" == "gz" ]; then
	  		# TODO: Don't assume '.tar.'. Check to make sure.
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.tar.gz"
	  	elif [ "$DOWNLOAD_FILE_EXTENSION_" == "zip" ]; then
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.zip"
	  	elif [ "$DOWNLOAD_FILE_EXTENSION_" == "phar" ]; then
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.phar"
	  	else
			echo "$BO_LOG_PREFIX""ERROR: Derived file extension '$DOWNLOAD_FILE_EXTENSION_' from url '$DOWNLOAD_URL_' not supported!"
			return 1
	  	fi
	  	if [ -e "$ARCHIVE_DOWNLOAD_PATH__" ]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Download path '$ARCHIVE_DOWNLOAD_PATH__' exists. Removing."
			rm -Rf "$ARCHIVE_DOWNLOAD_PATH__"
	  	fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Downloading '$DOWNLOAD_URL_' to '$ARCHIVE_DOWNLOAD_PATH__'"
		download -s "$DOWNLOAD_URL_" -o "$ARCHIVE_DOWNLOAD_PATH__" || {
			echo >&2 "$BO_LOG_PREFIX""Failed to download '$ARCHIVE_DOWNLOAD_PATH__'"
			return 1
		}
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Extracting '$ARCHIVE_DOWNLOAD_PATH__' to '$DOWNLOAD_PATH__'"
		BO_ensureExtracted "EXTRACTED_PATH__" "$ARCHIVE_DOWNLOAD_PATH__" || {
			echo >&2 "$BO_LOG_PREFIX""Failed to extract '$ARCHIVE_DOWNLOAD_PATH__'"
			return 1
		}
		if [ "$EXTRACTED_PATH__" != "$DOWNLOAD_PATH__" ]; then
			echo >&2 "$BO_LOG_PREFIX""ERROR: Actual extracted path '$EXTRACTED_PATH__' does not match expected path '$DOWNLOAD_PATH__'!"
			return 1
		fi
		BO_setResult $1 "$DOWNLOAD_PATH__"
	}

	function BO_ensureInSystemCache {
		local DOWNLOAD_PATH___
		BO_systemCachePath DOWNLOAD_PATH___ "$2" "$3"
		if [ ! -e "$DOWNLOAD_PATH___" ]; then
			BO_downloadToSystemCache DOWNLOAD_PATH___ "$2" "$3" "$4"
		fi
		BO_setResult $1 "$DOWNLOAD_PATH___"
	}

	function BO_ensureExtracted {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] args: $@"
		local DOWNLOADED_PATH_="$2"
		if [[ "$DOWNLOADED_PATH_" == *".tar.gz" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.tar\.gz$//g'`
			if [ ! -d "$EXTRACTED_PATH_" ]; then
				pushd "$(dirname $DOWNLOADED_PATH_)" > /dev/null
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
					mkdir "__$(basename $EXTRACTED_PATH_)"
					tar -xzf "$(basename $DOWNLOADED_PATH_)" -C "__$(basename $EXTRACTED_PATH_)"
					local RESOLVED_PATH=("$(pwd)"/__"$(basename $EXTRACTED_PATH_)"/*/*)
					mv -f "$(dirname "$RESOLVED_PATH")" "$(basename $EXTRACTED_PATH_)"
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
				popd > /dev/null
			fi
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:1"
			return 0
		elif [[ "$DOWNLOADED_PATH_" == *".zip" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.zip$//g'`
			if [ ! -d "$EXTRACTED_PATH_" ]; then
				pushd "$(dirname $DOWNLOADED_PATH_)" > /dev/null
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
					mkdir "__$(basename $EXTRACTED_PATH_)"
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] Extract '$(basename $DOWNLOADED_PATH_)' to '__$(basename $EXTRACTED_PATH_)' (pwd: '$(pwd)')"
					if ! which unzip > /dev/null; then
							echo >&2 "$BO_LOG_PREFIX""ERROR: You must have 'unzip' installed!"
							return 1
					fi
					unzip -q -d "__$(basename $EXTRACTED_PATH_)" "$(basename $DOWNLOADED_PATH_)"
					local RESOLVED_PATH=("__$(basename $EXTRACTED_PATH_)"/*)
					if [ -d "$RESOLVED_PATH" ]; then
						mv -f "$RESOLVED_PATH" "$(basename $EXTRACTED_PATH_)"
					else
						mkdir "$(basename $EXTRACTED_PATH_)"
						mv -f "$RESOLVED_PATH" "$(basename $EXTRACTED_PATH_)/$(basename $RESOLVED_PATH)"
					fi
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
				popd > /dev/null
			fi
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:2"
			return 0
		elif [[ "$DOWNLOADED_PATH_" == *".phar" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.phar$//g'`
			ln -s "$(basename "$DOWNLOADED_PATH_")" "$EXTRACTED_PATH_"
			# No need to extract.
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:3"
			return 0
		else
			echo >&2 "$BO_LOG_PREFIX""ERROR: Unable to extract path '$DOWNLOADED_PATH_'!"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:4"
			return 1
		fi
	}

	function BO_ensurePlugin {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] args: $@"
		local PLUGIN_NAME=`echo "$2" | perl -wnE 'say for /^(?:.+\/)?([^@\/]+)@?/g'`
		local PLUGIN_ID=`echo "$2" | sed 's/\//~/g'`
		local PLUGIN_VERSION=`echo "$2" | perl -wnE 'say for /@[v]{1}([^@]+)$/g'`
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_NAME: $PLUGIN_NAME"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_ID: $PLUGIN_ID"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_VERSION: $PLUGIN_VERSION"
		if [ ! -z "${PLUGIN_VERSION}" ]; then
				local PLUGIN_URL="https://github.com/bash-origin/$PLUGIN_NAME/archive/v$PLUGIN_VERSION.zip"
		else
				local PLUGIN_VERSION=`echo "$2" | perl -wnE 'say for /@([^@]+)$/g'`
				local PLUGIN_URL="https://github.com/bash-origin/$PLUGIN_NAME/archive/v$PLUGIN_VERSION.zip"
		fi
		local PLUGIN_PATH=""
		if [ "$BO_PLUGIN_SEARCH_DIRPATHS" != "" ] && [[ "$_BO_ensurePlugin__onlyDownloadedLocations" -ne 1 ]]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Look for plugin in '$BO_PLUGIN_SEARCH_DIRPATHS'"
				if [ ! -z "$BO_PLUGIN_SEARCH_DIRPATHS" ]; then
					# TODO: Loop over multiple paths separated by ":" - http://stackoverflow.com/a/918931/330439
					if [ -e "$BO_PLUGIN_SEARCH_DIRPATHS/$PLUGIN_NAME" ]; then
							PLUGIN_PATH="$BO_PLUGIN_SEARCH_DIRPATHS/$PLUGIN_NAME"
					fi
					if [ -e "$BO_PLUGIN_SEARCH_DIRPATHS/$PLUGIN_ID" ]; then
							PLUGIN_PATH="$BO_PLUGIN_SEARCH_DIRPATHS/$PLUGIN_ID"
					fi
					if [ "$PLUGIN_PATH" == "" ]; then
							if [ -e "$BO_PLUGIN_SEARCH_DIRPATHS/github.com~bash-origin~$PLUGIN_NAME" ]; then
								PLUGIN_PATH="$BO_PLUGIN_SEARCH_DIRPATHS/github.com~bash-origin~$PLUGIN_NAME"
							fi
					fi
				fi
		fi
		if [ "$PLUGIN_PATH" == "" ] && [ "$PLUGIN_VERSION" == "" ]; then
				local __latestVersionLookupUri="https://api.github.com/repos/bash-origin/$PLUGIN_NAME/tags"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Fetching latest version for 'github.com/bash-origin/$PLUGIN_NAME' from '$__latestVersionLookupUri'"
				set +e
				versions=`curl -s "$__latestVersionLookupUri" | grep '"name": "v'`
				set -e
				# TODO: If repository not found emit *insight* formatted message to indicate this so that
				#       tooling can auto-provision repository and then download accordingly.
				#       We can add a rest call here that can hold execution until the repository is
				#       provisioned and we can try again.
				if [ "$versions" == "" ]; then
						PLUGIN_VERSION="master"
						PLUGIN_URL="https://github.com/bash-origin/$PLUGIN_NAME/archive/$PLUGIN_VERSION.zip"
				else
						latestTag=`echo "$versions" | head -n 1 | perl -pe 's/^.+?"(v?[^"]+)",$/$1/'`
						if [ "$latestTag" == "" ]; then
								echo >&2 "$BO_LOG_PREFIX""ERROR: Latest tag could not be determined for plugin name '$PLUGIN_NAME'!"
								exit 1
						fi
						PLUGIN_VERSION="$latestTag"
						PLUGIN_URL="https://github.com/bash-origin/$PLUGIN_NAME/archive/$PLUGIN_VERSION.zip"
				fi
		fi
		if [ "$PLUGIN_PATH" == "" ]; then
			BO_isInSystemCache PLUGIN_PATH "github.com/bash-origin/$PLUGIN_NAME" "$PLUGIN_VERSION"
			if [ "$PLUGIN_PATH" == "" ]; then
				# TODO: Ask user before installing.
				[ -z "$BO_VERBOSE" ] || echo "$BO_LOG_PREFIX""Installing plugin '$PLUGIN_NAME' at version '$PLUGIN_VERSION'"
				BO_ensureInSystemCache PLUGIN_PATH "github.com/bash-origin/$PLUGIN_NAME" "$PLUGIN_VERSION" "$PLUGIN_URL"
			fi
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Found plugin path: $PLUGIN_PATH"
		BO_setResult $1 "$PLUGIN_PATH/$PLUGIN_NAME"
	}

	function BO_callDownloadedPlugin {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callDownloadedPlugin] args: $@"
			_BO_ensurePlugin__onlyDownloadedLocations=1
			BO_callPlugin "$@"
	}

	function BO_callPlugin {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] args: $@"
		local PLUGIN_PATH_
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] BO_SYSTEM_CACHE_DIR: $BO_SYSTEM_CACHE_DIR"
		if [[ "$_BO_ensurePlugin__onlyDownloadedLocations" -ne 1 ]] && [ -e "$BO_SYSTEM_CACHE_DIR/$1" ]; then
			PLUGIN_PATH_="$BO_SYSTEM_CACHE_DIR/$1"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] Using BO_SYSTEM_CACHE_DIR based path: $PLUGIN_PATH_"
		else
			if [[ "$1" == "/"* ]]; then
				PLUGIN_PATH_="$1"
				BO_log "$VERBOSE" "[BO_callPlugin] Using absolute path: $PLUGIN_PATH_"
			else
				BO_ensurePlugin "PLUGIN_PATH_" "$1"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] Using ensured plugin path: $PLUGIN_PATH_"
			fi
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Call plugin: $PLUGIN_PATH_"
		BO_sourcePrototype "$PLUGIN_PATH_"
		local func="$2"
		shift
		shift
		"$func" "$@"
	}

	function BO_trim_file_end {
			# Remove training space to ensure comparisons work across OSes
			# @see http://unix.stackexchange.com/a/81689/92833
			a=$(<$1); printf '%s\n' "$a" > $1
	}

	function BO_cecho {
		# Escape sequence and resets
		ESC_SEQ="\033["
		RESET_ALL="${ESC_SEQ}0m"
		RESET_BOLD="${ESC_SEQ}21m"
		RESET_UL="${ESC_SEQ}24m"
		NONE=""
		# Foreground colours
		FG_BLACK="30"
		FG_RED="31"
		FG_GREEN="32"
		FG_YELLOW="33"
		FG_BLUE="34"
		FG_MAGENTA="35"
		FG_CYAN="36"
		FG_WHITE="37"
		FG_BR_BLACK="90"
		FG_BR_RED="91"
		FG_BR_GREEN="92"
		FG_BR_YELLOW="93"
		FG_BR_BLUE="94"
		FG_BR_MAGENTA="95"
		FG_BR_CYAN="96"
		FG_BR_WHITE="97"
		# Background colours (optional)
		BG_BLACK="40"
		BG_RED="41"
		BG_GREEN="42"
		BG_YELLOW="43"
		BG_BLUE="44"
		BG_MAGENTA="45"
		BG_CYAN="46"
		BG_WHITE="47"
		# Font styles
		FS_REG="0"
		FS_BOLD="1"
		FS_UL="4"

		message=${1}
		foreground="NONE"
		style="FS_REG"
		background="NONE"

		if [ ! -z "${2}" ]; then
			foreground="FG_${2}"
		fi
		if [ ! -z "${3}" ]; then
			style="FS_${3}"
		fi
		if [ ! -z "${4}" ]; then
			background="BG_${4}"
		fi
		background="${!background}"
		if [ "${background}" != "" ]; then
			background=";${background}"
		fi

		echo -e "${ESC_SEQ}${!style};${!foreground}${background}m${message}${RESET_ALL}"
	}


	###############################
	# Act
	###############################

	function BO_self_install {
		BO_checkVerbose "VERBOSE" "$@"

		# TODO: Introduce external variable to set target install path
		local installTargetPath="$ORIGINAL_BO_ROOT_SCRIPT_PATH"
		if [ -z "$installTargetPath" ] || [ "$installTargetPath" == "$BO_ROOT_SCRIPT_PATH" ]; then
				# Target path not set so we use the default one
				BO_ensure_env_HOME "Use default .bash.origin"
				installTargetPath="$HOME/.bash.origin"
		elif [ ! -e "$installTargetPath" ]; then
			# We may have an old 'BO_ROOT_SCRIPT_PATH' set that no longer exists.
			# We assue that is the case if the parent path no longer exists.
			# If you don't want the path to be reset make sure the parent path exists!
			if [ ! -e "$(dirname $installTargetPath)" ]; then
				BO_ensure_env_HOME "Use default .bash.origin"
				installTargetPath="$HOME/.bash.origin"
			fi
		fi
		if [ "$installTargetPath" == "$1" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Skip copy of '$1' to '$installTargetPath' as path is the same."
		else
				if [ "$2" == "-f" ]; then
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Removing '$installTargetPath' due to forced-install (BO install -f)"
					rm -f "$installTargetPath" || true
				fi
				if [ ! -e "$installTargetPath" ]; then
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Copying '$1' to '$installTargetPath'"
					cp -f "$1" "$installTargetPath"
				else
					# TODO: Copy if version has changed.
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Skip copy of '$1' as '$installTargetPath' already exists."
				fi
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""bash.origin installed!"
		fi
		BO_ensure_nvm
	}

	function BO_self_update {
echo "TODO: BO_self_update"
exit 1
		local BASH_ORIGIN_PATH
		local FOUND_PREVIOUS_CACHE="0"
	  	if [ -d "$BO_SYSTEM_CACHE_DIR" ]; then
	  		FOUND_PREVIOUS_CACHE="1"
	  	fi
		BO_downloadToSystemCache BASH_ORIGIN_PATH "github.com/bash-origin/bash.origin" "master" "bash.origin" "$BO_ROOT_SOURCE_URL?t=$(date +%s)"
		BO_self_install "$BASH_ORIGIN_PATH" -f
		if [ "$FOUND_PREVIOUS_CACHE" == "0" ]; then
			rm -Rf "$BO_SYSTEM_CACHE_DIR"
		fi
		echo "$BO_LOG_PREFIX""bash.origin updated!"
	}

	# Bash Origin Bin invocation
	if [ "$1" == "BOB" ]; then

			# TODO: Do any other init work?

			if [ "$2" == "BOE" ]; then
					# When used via '. bash.origin BOE'
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Sourced 'bash.origin' environment. (args: $@)"
			else
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Loaded 'bash.origin' environment. (args: $@)"
					func="$2"
					shift
					shift
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""func: $func"
					. "$func" "$@"
			fi

	# Bash Origin Script invocation
  elif [ "$1" == "BOS" ]; then
			local ___old_BO_OPTIMIZED="$_BO_OPTIMIZED"
			if [ "$3" == "-c" ]; then
					_BO_OPTIMIZED=0
			fi
			# Load provided URI as bash.origin.script module
			BO_requireModule "${2}" as "module" ${*:3}
			_BO_OPTIMIZED="$___old_BO_OPTIMIZED"

	# Bash Origin Internal Util invocation
	elif [ "$1" == "BO" ]; then
		if [ ! -z "$VERBOSE" ]; then
				export BO_VERBOSE=1
		fi
		## Usage: `bash.origin BO install [-f]
		if [ "$2" == "install" ]; then
			# TODO: Instead of using '$BO_DIR' use '$BO_FILE' which should
			#       point to this file.
			if [ -e "$BO_DIR/bash.origin" ]; then
				BO_self_install "$BO_DIR/bash.origin" "$3"
			elif [ -e "$BO_DIR/.bash.origin" ]; then
				BO_self_install "$BO_DIR/.bash.origin" "$3"
			else
				echo "[bash.origin] ERROR: Could not locate path to source!"
				exit 1
			fi
			exit 0
		elif [ "$2" == "update" ]; then
			BO_self_update
			exit 0
		fi
		echo "$BO_LOG_PREFIX""ERROR: Unknown BO command '$2'!"
		exit 1
	elif [ "$BO" == "install" ]; then
		BO_self_update
		BO=""
		exit 0
	fi
}
init $@
