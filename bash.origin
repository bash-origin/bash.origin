#!/bin/bash
# Source: https://github.com/cadorn/bash.origin
# License: http://unlicense.org/
function init {

	if echo "$@" | grep -q -Ee '(\$|\s)--debug(\s|\$)'; then
		export BO_VERBOSE=1
		export VERBOSE=1
	elif echo "$npm_config_argv" | grep -q -Ee '"--debug"'; then
		export BO_VERBOSE=1
		export VERBOSE=1
	fi

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] --- START --- (pwd: $(pwd))"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] SHELL: $SHELL"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] args: $@"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] which bash: $(which bash)"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] bash --version: $(bash --version)"

	if [ ! -z "$BO_LOADED" ]; then
			# If we loaded before we do not load again.
			[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] Skip due to BO_LOADED=1"
			return;
	fi

	if ! which perl > /dev/null; then
			echo -e >&2 "[BO] ERROR: You must have 'perl' installed!\n"
			exit 1
	fi

	# If 'SHELL' is set to 'bash' that is good enough for us.
	if [ "$(echo "$SHELL" | perl -pe 's/^.*(bash)$/$1/')" != "bash" ]; then
			[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] SHELL is not 'bash': $SHELL"

			# 'SHELL' is not what we need so we try and verify that we are running in `bash`
			# by looking for `bash` in the process description.
			# NOTE: This does not work reliably (e.g. on alpine docker image)
			#set +e
			#[ -z "$BO_VERBOSE" ] || echo "[bash.origin] Running: ps | perl -pe \"s/^\s*$$\s+.*?(bash).*?$/\$1/\" | grep '^bash$'"
			#local __BO_SHELL="$(ps | perl -pe "s/^\s*$$\s+.*?(bash).*?$/\$1/" | grep '^bash$')"
			#[ -z "$BO_VERBOSE" ] || echo "[bash.origin] __BO_SHELL: $__BO_SHELL"
			#set -e

			#if [ "$(ps -p $$ | tail -1 | awk '{ print $4 }' | perl -pe 's/^.*(bash)$/$1/')" != "bash" ]; then

			# TODO: Use additional ways to detect if we are running in bash.

			if [ "$__BO_SHELL" != "bash" ]; then
					echo -e >&2 ""
					echo -e >&2 "[BO] WARNING: Your 'SHELL' environment variable is set to '$SHELL' while it should be set to '$(which bash)'\n"
					echo -e >&2 "[BO] ERROR: You must be using the 'bash' shell interpreter!\n"
					echo -e >&2 "[BO] ACTION: Enter the bash shell for this session only first by running:\n"
					echo -e >&2 "             SHELL=$(which bash) $(which bash)\n"
					echo -e >&2 "[BO] ACTION[macOS]: or change your default shell to the bash shell by running:\n"
					echo -e >&2 "             sudo dscl localhost -change /Local/Default/Users/$USER UserShell $(which zsh) $(which bash)"
					echo -e >&2 "             # Now open a new terminal\n"
					exit 1
			fi
	fi

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] $SHELL --version: $($SHELL --version)"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_BASH_ALLOW_3: $BO_BASH_ALLOW_3"

	if [[ $BO_BASH_ALLOW_3 != 1 ]] && [[ "$($SHELL --version)" != "GNU bash, version 4."* ]]; then
			if [ "$(which bash)" != "$SHELL" ]; then
					if [[ "$(bash --version)" == "GNU bash, version 4."* ]]; then
							# We update the SHELL to where 'bash' actually is.
							SHELL="$(which bash)"
					else
							echo -e >&2 "[BO] ERROR: You are using bash version '$($SHELL --version)' instead of version 4!\n"
							echo -e >&2 "[BO] ACTION: Install bash version 4. On OSX you can use:\n"
							echo -e >&2 "             brew install bash\n"
							echo -e >&2 "[BO] ACTION: Then call your script again using:\n"
							echo -e >&2 "             SHELL=/usr/local/bin/bash /usr/local/bin/bash <ScriptPath>\n"
							echo -e >&2 "[BO] ACTION: or change your default shell to the bash shell by running:\n"
							echo -e >&2 "             sudo dscl localhost -change /Local/Default/Users/$USER UserShell $(which zsh) /bin/bash"
							echo -e >&2 "             # Now open a new terminal\n"
							exit 1
					fi
			fi
	fi


	if [ -z "$ORIGINAL_BO_CLI_ARGS" ]; then
			export ORIGINAL_BO_CLI_ARGS="$@"
	fi
	local ORIGINAL_BO_ROOT_SCRIPT_PATH="$BO_ROOT_SCRIPT_PATH"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] ORIGINAL_BO_CLI_ARGS: $ORIGINAL_BO_CLI_ARGS"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] ORIGINAL_BO_ROOT_SCRIPT_PATH: $ORIGINAL_BO_ROOT_SCRIPT_PATH"


	###############################
	# Declare Boot Globals
	###############################

	BO_LOG_PREFIX="[BO] "
	BO_READ_SELF_BASH_SOURCE="$""{BASH_SOURCE[0]:-$""0}"


	###############################
	# Declare Boot Functions
	###############################

	function BO_cecho {
		# Escape sequence and resets
		ESC_SEQ="\033["
		RESET_ALL="${ESC_SEQ}0m"
		RESET_BOLD="${ESC_SEQ}21m"
		RESET_UL="${ESC_SEQ}24m"
		NONE=""
		# Foreground colours
		FG_BLACK="30"
		FG_RED="31"
		FG_GREEN="32"
		FG_YELLOW="33"
		FG_BLUE="34"
		FG_MAGENTA="35"
		FG_CYAN="36"
		FG_WHITE="37"
		FG_BR_BLACK="90"
		FG_BR_RED="91"
		FG_BR_GREEN="92"
		FG_BR_YELLOW="93"
		FG_BR_BLUE="94"
		FG_BR_MAGENTA="95"
		FG_BR_CYAN="96"
		FG_BR_WHITE="97"
		# Background colours (optional)
		BG_BLACK="40"
		BG_RED="41"
		BG_GREEN="42"
		BG_YELLOW="43"
		BG_BLUE="44"
		BG_MAGENTA="45"
		BG_CYAN="46"
		BG_WHITE="47"
		# Font styles
		FS_REG="0"
		FS_BOLD="1"
		FS_UL="4"

		message=${1}
		foreground="NONE"
		style="FS_REG"
		background="NONE"

		if [ ! -z "${2}" ]; then
			foreground="FG_${2}"
		fi
		if [ ! -z "${3}" ]; then
			style="FS_${3}"
		fi
		if [ ! -z "${4}" ]; then
			background="BG_${4}"
		fi
		background="${!background}"
		if [ "${background}" != "" ]; then
			background=";${background}"
		fi

		echo -e "${ESC_SEQ}${!style};${!foreground}${background}m${message}${RESET_ALL}"
	}

	function BO_has {
		if type "$1" > /dev/null 2>&1 || hash "$1" > /dev/null 2>&1; then
			return 0
		fi
		return 1
	}

	function BO_hash {
		echo -n "$1" | openssl sha1
	}

	function BO_log {
		if [ "$1" != "1" ]; then
			return;
		fi
		echo -e >&2 "${*:2}"
	}

	function BO_exit_error {
		echo >&2 "$(BO_cecho "ERROR: $1" RED BOLD)"
		exit 1
	}

	function BO_ensure_env_HOME {
		# Should fail if not set or set to empty string.
		if [ ! -n "${HOME}" ] || [ "${HOME}" == "" ]; then
			echo >&2 "[BO] ERROR: 'HOME' environment variable is not set! Used by: $1"
			exit 1
		fi
	}

	function BO_setResult {
		local  __resultvar=$1
	    eval $__resultvar="'$2'"
		return 0
	}

	function BO_deriveSelfDir {
		# @source http://stackoverflow.com/a/246128/330439
		local SOURCE="$2"
		local DIR=""
		while [ -h "$SOURCE" ]; do
		  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		  SOURCE="$(readlink "$SOURCE")"
		  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
		done
		BO_setResult $1 "$( cd -P "$( dirname "$SOURCE" )" && pwd )"
		return 0
	}

	function BO_sourceProfile {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] args: $@"
		if [[ $BO_ENABLE_SOURCE_PROFILE == 0 ]]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] return due to 'BO_ENABLE_SOURCE_PROFILE == 0'"
			return 0
		fi
		if [ ! -z "$CIRCLE_SHA1" ]; then
			# On circleci we do not load the profile again
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] return due to 'CIRCLE_SHA1' set"
			return 0
		fi
		# TODO: Allow sourcing multiple times if 'force' argument provided.
		if [ -z "$BO_sourceProfile__sourced" ]; then
			export BO_sourceProfile__sourced="1"
			BO_ensure_env_HOME "BO_sourceProfile"
			local currentDirectory="$(pwd)"
			local currentPATH="$PATH"
			local currentNVM=`printenv | grep '^NVM_'`
			if [ -f "$HOME/.bash_profile" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Source from '$HOME/.bash_profile' (pwd: ${currentDirectory})"
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						. "$HOME/.bash_profile" >/dev/null 2>&1
				else
						. "$HOME/.bash_profile"
				fi
				set -e
			elif [ -f "$HOME/.profile" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Source from '$HOME/.profile' (pwd: ${currentDirectory})"
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						. "$HOME/.profile" >/dev/null 2>&1
				else
						. "$HOME/.profile"
				fi
				set -e
			fi
			if [ "$(pwd)" != "${currentDirectory}" ]; then
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] Changing directory back to '${currentDirectory}' (pwd: $(pwd))"
					cd "${currentDirectory}"
			fi
			export PATH="${currentPATH}"
			eval "$currentNVM"
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceProfile] DONE"
	}

	function BO_has_cli_arg {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] args: $@"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] ORIGINAL_BO_CLI_ARGS: $ORIGINAL_BO_CLI_ARGS"
		if echo "$ORIGINAL_BO_CLI_ARGS" | grep -q -Ee "(^|\s)$1(\s|\$)"; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] found arg '$1' in 'ORIGINAL_BO_CLI_ARGS'"
			return 0
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] npm_config_argv: $npm_config_argv"
		if [[ "$npm_config_argv" =~ "$1" ]]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] found arg '$1' in 'npm_config_argv'"
			return 0
		fi
		#if echo "$npm_config_argv" | grep -q -Ee '"$1"'; then
		#	[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] found arg '$1' in 'npm_config_argv'"
		#	return 0
		#fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_cli_arg] Did not find arg '$1' in ORIGINAL_BO_CLI_ARGS ($ORIGINAL_BO_CLI_ARGS) nor npm_config_argv ($npm_config_argv)"
		return 1
	}

	function BO_has_arg {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_has_arg] args: $@"
		if echo "${*:2}" | grep -q -Ee "(^|\s)$1(\s|\$)"; then
			return 0
		fi
		return 1
	}

	function BO_checkVerbose {
		local _VERBOSE="$VERBOSE"
		# Look for '-v', '--verbose', '-d' or '--debug' flags.
		if echo "$@" | grep -q -Ee '(^|\s)--?([vd]|verbose|debug)(\s|\$)'; then
		    _VERBOSE="1"
			BO_log "$BO_VERBOSE" "[BO_checkVerbose] enable due to verbose command arg: $@"
		fi
		if echo "$npm_config_argv" | grep -q -Ee '"--?([vd]|verbose|debug)"'; then
		    _VERBOSE="1"
			BO_log "$BO_VERBOSE" "[BO_checkVerbose] enable due to verbose npm_config_argv arg: $npm_config_argv"
		fi
#		if [ "$_VERBOSE" == "1" ]; then
#			BO_log "$_VERBOSE" "[BO_checkVerbose] Verbose Enabled: $_VERBOSE"
#		fi
		BO_setResult "$1" "$_VERBOSE"
	}

	function BO_resetLoaded {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_resetLoaded]"
		export BO_LOADED=
		export BO_IS_SOURCING=
		export BO_sourceProfile__sourced=
	}
	

	###############################
	# Boot self
	###############################

	if [ -z "$BO_PREFIX_DIR" ]; then
		function useFallbackPrefix {
		    # We fall back to '~/.bash.origin.cache/'
			BO_ensure_env_HOME "Use default '$BO_DIR/.bash.origin.cache' for BO_PREFIX_DIR"
			export BO_PREFIX_DIR="$HOME/.bash.origin.cache"
			[ -e "$BO_PREFIX_DIR" ] || mkdir "$BO_PREFIX_DIR"
		}
		# If we have a cache in our home dir we use that over all other
		if [ -e "$HOME/.bash.origin.cache" ]; then
			export BO_PREFIX_DIR="$HOME/.bash.origin.cache"
		# If 'node' is from an NVM install we locate the cache into the active nvm 'lib' directory.
		elif BO_has node && [ ! -z "$NVM_DIR" ] && [ ! -z "$NVM_BIN" ]; then
			export BO_PREFIX_DIR="$(dirname $(dirname "$NVM_BIN"))"
		elif [ -w "/usr/local" ]; then
			# '/usr/local' is writable so we use that if we can create a cache directory below.
			export BO_PREFIX_DIR="/usr/local"
			if [ ! -e "/usr/local/lib/bash.origin.cache" ]; then
				mkdir -p "/usr/local/lib/bash.origin.cache" || useFallbackPrefix
			fi
		else
			useFallbackPrefix
		fi
	fi
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_PREFIX_DIR: $BO_PREFIX_DIR"


	# NOTE: We no longer source the profile automatically!
	if [ -z "$BO_ENABLE_SOURCE_PROFILE" ]; then
		BO_ENABLE_SOURCE_PROFILE=0;
	fi
	BO_sourceProfile

	eval BO_SELF_BASH_SOURCE="$BO_READ_SELF_BASH_SOURCE"
	BO_deriveSelfDir ___TMP___ "$BO_SELF_BASH_SOURCE"
	export BO_DIR="$___TMP___"

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_DIR: $BO_DIR"

	BO_checkVerbose "VERBOSE" "$@"
	export VERBOSE
	export BO_VERBOSE

	[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[bash.origin] BO_VERBOSE: ${BO_VERBOSE}"
	[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[bash.origin] VERBOSE: ${VERBOSE}"

	export BO_LOADED=1

	# NOTE: Variables starting with '_BO_' are for primarily internal use
	#       and should not be set externally other than to force a specific
	#       internal state for debugging purposes.
	if [ -z "$_BO_OPTIMIZED" ]; then
		# If not set we set it based on BO_VERBOSE.
		if [ -z "$BO_VERBOSE" ]; then
			export _BO_OPTIMIZED=1
		else
			export _BO_OPTIMIZED=0
		fi
	fi

	if echo "$@" | grep -q -Ee '(\$|\s)--compile(\s|\$)'; then
		export _BO_OPTIMIZED=0
	elif echo "$npm_config_argv" | grep -q -Ee '"--compile"'; then
		export _BO_OPTIMIZED=0
	fi


	###############################
	# Delegate if requested
	###############################

	if [ "$BO_ROOT_SCRIPT_PATH" != "" ]; then
		if [ "$1" != "BO" ]; then
			if [ "$2" != "install" ]; then
				if [ -e "$BO_ROOT_SCRIPT_PATH" ]; then
					local ORIGINAL_BO_ROOT_SCRIPT_DIR
					BO_deriveSelfDir ORIGINAL_BO_ROOT_SCRIPT_DIR "$BO_ROOT_SCRIPT_PATH"
					if [ "$BO_DIR" != "$ORIGINAL_BO_ROOT_SCRIPT_DIR" ]; then
						[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] Delegate to BO_ROOT_SCRIPT_PATH: $BO_ROOT_SCRIPT_PATH"
						# Delegate to the Bash.Origin script at 'BO_ROOT_SCRIPT_PATH'
						# which was set before calling us.
						export BO_LOADED=
						. "$BO_ROOT_SCRIPT_PATH"
						return;
					fi
				else
					BO_ensure_env_HOME "Delegate to BO_ROOT_SCRIPT_PATH"
					if [ "$BO_ROOT_SCRIPT_PATH" != "$BO_PREFIX_DIR/bin/bash.origin" ]; then
						echo >&2 "[bash.origin] ERROR: 'BO_ROOT_SCRIPT_PATH' ($BO_ROOT_SCRIPT_PATH) not found!"
						exit 1
					fi
				fi
			fi
		fi
	else
		if [ -e "$BO_DIR/bash.origin" ]; then
			BO_ROOT_SCRIPT_PATH="$BO_DIR/bash.origin"
		elif [ -e "$BO_DIR/.bash.origin" ]; then
			BO_ROOT_SCRIPT_PATH="$BO_DIR/.bash.origin"
		else
			BO_ROOT_SCRIPT_PATH="$BO_PREFIX_DIR/bin/bash.origin"
		fi
	fi

	export BO_ROOT_SCRIPT_PATH
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_ROOT_SCRIPT_PATH: $BO_ROOT_SCRIPT_PATH"

	function BO_ensure_bo_script_bin {
		[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin][BO_ensure_bo_script_bin] args: $@"
		# Ensure BO_ROOT_SCRIPT_PATH exists
		if [ ! -e "$BO_ROOT_SCRIPT_PATH" ]; then
			local _binBaseDir="$1"
			# Ensure 'bash.origin.script' exists
			if [ ! -e "$_binBaseDir/bash.origin.script" ]; then
				[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] Placing wrapper script for 'bash.origin.script' at '$_binBaseDir/bash.origin.script'"
				# TODO: Dynamically feed based on 'BO_resetLoaded'
				echo -e "#!/usr/bin/env bash\nBO_LOADED=\nBO_IS_SOURCING=\nBO_sourceProfile__sourced=\n__ON_INIT__BO_IS_SOURCING=\n. $BO_ROOT_SCRIPT_PATH BOS $""@" > "$_binBaseDir/bash.origin.script"
				chmod u+x "$_binBaseDir/bash.origin.script"
			fi
			# Ensure 'bash.origin' exists
			if [ ! -e "$_binBaseDir/bash.origin" ]; then
				[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] Placing wrapper script for 'bash.origin' at '$_binBaseDir/bash.origin'"
				# TODO: Dynamically feed based on 'BO_resetLoaded'
				echo -e "#!/usr/bin/env bash\nBO_LOADED=\nBO_IS_SOURCING=\nBO_sourceProfile__sourced=\n__ON_INIT__BO_IS_SOURCING=\n. $BO_ROOT_SCRIPT_PATH BOB $""@" > "$_binBaseDir/bash.origin"
				chmod u+x "$_binBaseDir/bash.origin"
			fi
		fi
	}

	BO_ensure_bo_script_bin "$(dirname "$BO_ROOT_SCRIPT_PATH")"


	###############################
	# Declare Globals
	###############################

	if [ "$BO_IS_SOURCING" == "1" ]; then
		__ON_INIT__BO_IS_SOURCING="1"
	else
		__ON_INIT__BO_IS_SOURCING="0"
	fi

	BO_ROOT_SOURCE_URL="https://raw.githubusercontent.com/bash-origin/bash.origin/master/bash.origin"
	if [ -z "$BO_GLOBAL_SYSTEM_CACHE_DIR" ]; then
		BO_ensure_env_HOME "Use default '$BO_PREFIX_DIR/lib/bash.origin.cache'"
		BO_GLOBAL_SYSTEM_CACHE_DIR="$BO_PREFIX_DIR/lib/bash.origin.cache"
	fi
	export BO_GLOBAL_SYSTEM_CACHE_DIR
	if [ -z "$BO_SYSTEM_CACHE_DIR" ]; then
		BO_SYSTEM_CACHE_DIR="$BO_GLOBAL_SYSTEM_CACHE_DIR"
	fi
	export BO_SYSTEM_CACHE_DIR

	if [ -z "$BO_VERSION_NVM" ]; then
		BO_VERSION_NVM="0.33.4"
	fi


	function BO_major_node_version {
		if ! BO_has node; then
			BO_exit_error "'node' command not found! If you want to provision it dynamically, set 'BO_VERSION_NVM_NODE'."
		fi
		echo "$(node --version 2>&1 | perl -pe 's/^v(\d+).+$/$1/')"
	}

	if [[ $BO_ASSUME_NODE != 1 ]]; then
		if [ ! -z "$BO_VERSION_NODE" ]; then
			# NOTE: This code will only run ONCE!

			# If 'BO_VERSION_NODE' is set we make sure node is found and
			# the version matches and then never check it again.
			if ! BO_has node; then
				BO_exit_error "'node' command not found! If you want to provision it dynamically, set 'BO_VERSION_NODE' et.al."			
			fi
			if [ "$(BO_major_node_version)" != "$BO_VERSION_NODE" ]; then
				BO_exit_error "'node' version '$(BO_major_node_version)' from environment does not match version '$BO_VERSION_NODE' declared by 'BO_VERSION_NODE'. Make sure to only set the MAJOR version!"
			fi
			# From now on we do not check the 'node' version again
			# and just assume we have the correct version set
			# by the virture of:
			export BO_ASSUME_NODE=1

			export BO_VERSION_NVM_NODE="$BO_VERSION_NODE"
		fi
	fi

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_VERSION_NODE: $BO_VERSION_NODE"

	# Holds the node version that was detected from outside.
	function BO_original_node_version {
		if [ -z "$ORIGINAL_BO_VERSION_NODE" ]; then
			ORIGINAL_BO_VERSION_NODE="$(BO_major_node_version)"
		fi
		echo "$ORIGINAL_BO_VERSION_NODE"
	}

	if [ -z "$BO_VERSION_NVM_NODE" ]; then
		BO_VERSION_NVM_NODE="$(BO_original_node_version)"
	fi
	if [ -z "$BO_VERSION_RECENT_NODE" ]; then
		# NOTE: The idea of 'BO_VERSION_RECENT_NODE' is to hold a most recent version
		# of 'node' while 'BO_VERSION_NVM_NODE' holds the main *system* version.
		BO_VERSION_RECENT_NODE="$BO_VERSION_NVM_NODE"
	fi

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] ORIGINAL_BO_VERSION_NODE: $ORIGINAL_BO_VERSION_NODE"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_VERSION_NVM_NODE: $BO_VERSION_NVM_NODE"
	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_VERSION_RECENT_NODE: $BO_VERSION_RECENT_NODE"


	if [ -z "$BO_VERSION_NVM_IOJS" ]; then
		# DEPRECATED
		BO_VERSION_NVM_IOJS="iojs-v3.0.0"
	fi
	if [ -z "$BO_VERSION_SMI_CLI" ]; then
		BO_VERSION_SMI_CLI="0.35.14"
	fi

	[ -z "$BO_VERBOSE" ] || echo >&2 "[bash.origin] BO_GLOBAL_SYSTEM_CACHE_DIR: $BO_GLOBAL_SYSTEM_CACHE_DIR"


	###############################
	# Declare Utility Functions
	###############################

	function BO_now {
			BO_setResult "$1" "$(date +%s)"
	}

	function BO_format {
		if [ "$1" != "1" ]; then
			return;
		fi
		if [ "$2" == "HEADER" ]; then
			echo >&2 "##################################################";
			echo >&2 "# $3";
			echo >&2 "##################################################";
		fi
		if [ "$2" == "FOOTER" ]; then
			echo >&2 "##################################################";
			echo >&2 ""
		fi
	}

	function BO_replace {
		echo -n "$(echo "$1" | perl -pe "s/$2/\$1/")"
	}

	function BO_test {
		if [ "$(echo "$1" | perl -wnE "say for /($2)/")" == "" ]; then
			return 1
		fi
		return 0
	}

	function BO_ensure_dir {
		if [ ! -e "$1" ]; then
			mkdir -p "$1"
		fi
	}

	function BO_ensure_parent_dir {
		if [ ! -e "$(dirname "$1")" ]; then
			mkdir -p "$(dirname "$1")"
		fi
	}

	function BO_ensure_empty_path {
		if [ ! -e "$1" ]; then
			# Path does not exist
			BO_ensure_dir "$1"
			return 0;
		fi
		# Path exists; check if empty
		# @source https://stackoverflow.com/a/20456797/330439
		if find "$1" -mindepth 1 -print -quit | grep -q .; then
			# has content
			return 1;
		fi
		# is empty
		return 0;
	}

	function BO_find_path_up {
		local path=$1
		while [[ "$path" != "" && ! -e "$path/$2" ]]; do
			path=${path%/*}
		done
		echo "$path/$2"
	}

	function BO_mark_time {
		# TODO: Refactor to setup a rolling timer.
		local cmd="$1"
		local timer_format

		if [[ -n "$2" ]]; then
			timer_format="$2"
		else
			timer_format='%-Mm %-Ss'
		fi
		
		case $cmd in
			start)
				# This can't be local because we need it to persist across calls.
				_timer_StartSecs=$(date +'%s')
				;;
			stop)
				if [[ ! $_timer_StartSecs ]]; then
					echo "$FUNCNAME did not record a start." >&2
					return 1
				fi
				
				local _timer_StopSecs=$(date +'%s')
				local DiffSecs=$(($_timer_StopSecs-$_timer_StartSecs))
				local TimeLapse=$(date -u -d@"$DiffSecs" +"$timer_format")
				
				echo "$TimeLapse"
				;;
			*)
				echo "$FUNCNAME: Invalid command '$cmd'." >&2
				return 1
				;;
		esac
	}


	if echo "$@" | grep -q -Ee '(\$|\s)--install-only(\s|\$)'; then
		BO_FLAG_INSTALL_ONLY=1
	elif echo "$npm_config_argv" | grep -q -Ee '"--install-only"'; then
		BO_FLAG_INSTALL_ONLY=1
	fi

	function BO_exit_if_install_only {
		installFunc="$1"
		function doInstall {
			if [ ! -z "$installFunc" ]; then
				"$installFunc"
			fi
		}
		function doExit {
			doInstall
			exit 0
		}
		if [[ $BO_FLAG_INSTALL_ONLY == 1 ]]; then
			doExit
		elif echo "$@" | grep -q -Ee '(\$|\s)--install-only(\s|\$)'; then
			doExit
		elif echo "$npm_config_argv" | grep -q -Ee '"--install-only"'; then
			doExit
		else
			doInstall
		fi
	}


	function BO_sudo {
		# TODO: Detect if we even need to ask for sudo. If not just run command.
		local NEED_TO_ASK="1"
		if [ "$NEED_TO_ASK" == "1" ]; then
			echo >&2 "$BO_LOG_PREFIX""WARNING: Asking for sudo access to run: $1"
		fi
		sudo $1
	}


	function BO_parse_args {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_parse_args] args: $@"
		# TODO: Relocate this into external module so we can install 'minimist'
		#       or use pure bash implementation.

		BO_ensureInSystemCache "__minimistPath" "github.com/substack/minimist" "1.2.0" "https://github.com/substack/minimist/archive/1.2.0.zip"

        local parsedArgs=$(echo -e $(BO_run_silent_node --eval '
			const PATH = require("path");
			const FS = require("fs");
			const MINIMIST = require("'$__minimistPath'");

            const VAR_PREFIX = process.argv[1];

            var vars = {};
            function exportVar (name, value) {
				name = name.replace(/-/g, "_");
                vars[VAR_PREFIX + name] = ("" + value);
            }

            const rawArgsArray = process.argv.slice(2);
            const argsArray = [];
			var argState = null;
			rawArgsArray.forEach(function (arg) {
				if (argState === "concat") {
					argsArray[argsArray.length-1] += " " + arg;
					if (!/^"/.test(arg) && /"$/.test(arg)) {
						argState = null;
						argsArray[argsArray.length-1] = argsArray[argsArray.length-1].replace(/^"(.+)"$/, "$1");
					}
				} else {
					argsArray.push(arg);
					if (/^--/.test(arg)) {
						argState = "opt";
					}
					if (argState === "opt") {
						if (/^"/.test(arg) && !/"$/.test(arg)) {
							argState = "concat";
						}
					}
				}
			});

            exportVar("_0", argsArray.join(" "));

            const args = MINIMIST(argsArray);

            Object.keys(args).forEach(function (name) {
                if (name === "_") {
                    args[name].forEach(function (value, i) {
                        exportVar("_" + (i + 1), value);
                    });
                } else {
                    exportVar("_OPT_" + name, args[name]);
                }
            });

            Object.keys(vars).forEach(function (name) {
                process.stdout.write(name + "=\"" + vars[name] + "\"\\n");
            });
        ' "$@"))
        [ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$parsedArgs"
		eval "$parsedArgs" || {
	        BO_log "1" "ARGS: $parsedArgs"
		}
	}

	function BO_compileModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] args: $@"
			# TODO: Resolve './' and aliased paths based on mappings.
			local _raw_module_source_path="$2"
			local _compiled_module_source_path="$(dirname "$2")/.~$(basename "$2")~compiled.module.bash.sh"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] _raw_module_source_path: $(stat -f "%m%t%Sm %N" $_raw_module_source_path)"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] _compiled_module_source_path: $(stat -f "%m%t%Sm %N" $_compiled_module_source_path) 2> /dev/null"
			# If source file is newer than compiled file
			# TODO: Compile if 'bash.origin.modules' plugin implementation directory is newer than compiled module.
			if [ ! -e "${_compiled_module_source_path}" ] || [ $_BO_OPTIMIZED == 0 ] || [ ${_raw_module_source_path} -nt ${_compiled_module_source_path} ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] Compile source '${_raw_module_source_path}' to '${_compiled_module_source_path}' (pwd: $(pwd), _BO_OPTIMIZED: $_BO_OPTIMIZED)"
    			BO_callPlugin "bash.origin.modules" compile ${_raw_module_source_path} ${_compiled_module_source_path}
			else
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] Skip compile as source has not changed."
			fi
			BO_setResult "$1" "${_compiled_module_source_path}"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_compileModule] DONE"
	}

	function BO_requireModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] args: $@"
			if [[ "${BASH_VERSION}" != "4."* ]]; then
					echo >&2 "$BO_LOG_PREFIX""ERROR: You must be using bash version 4 or newer to use 'BO_requireModule' (yours is '${BASH_VERSION}')! Put this '#!/usr/bin/env bash' shebang at the top of the script file you are executing to get the 'bash' command from your PATH instead of default for your shell."
					exit 1
			fi
			if [ "$2" != "as" ]; then
						echo >&2 "$BO_LOG_PREFIX""ERROR: Second argument to BO_requireModule should be 'as'!"
						exit 1
			fi
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] ___bo_module_instance_caller_dirname___: $___bo_module_instance_caller_dirname___"
			varName=""
			if [ ! -z "$___bo_module_instance_caller_dirname___" ]; then
				varName="$3__CALLER_DIRNAME__"
				export ${varName}="$___bo_module_instance_caller_dirname___"
			fi
			if [[ "${1}" == "."* ]]; then
					# Relative include based on PWD is used from outside a module
					# and based on path of parent module if used from inside module.
					BO_sourceModule "$(pwd)/$1"
			elif [[ "${1}" == "@"* ]]; then

					if [[ "${1}" == "@com.github/"* ]] || [[ "${1}" == "@github.com~"* ]]; then

						if [[ "${1}" == "@com.github/"* ]]; then

							local PLUGIN_URI_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									uriParts[1] = uriParts[1].split(".");
									uriParts[1].reverse();
									uriParts[1] = uriParts[1].join(".");
									process.stdout.write(uriParts[1] + "/" + uriParts[2]);
							' "${1}"`
							local PLUGIN_URI_SUB_PATH_=""
							local PLUGIN_VERSION_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[3]);
							' "${1}"`
						else

							local PLUGIN_URI_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[1]);
							' "${1}"`
							local PLUGIN_URI_SUB_PATH_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[2]);
							' "${1}"`
							local PLUGIN_VERSION_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@([^\/]+)\/(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[3]);
							' "${1}"`
						fi

							local PLUGIN_PATH_
							BO_ensurePlugin "PLUGIN_PATH_" "$PLUGIN_URI_"
							PLUGIN_PATH_="$(dirname "${PLUGIN_PATH_}")"
							if [ "${PLUGIN_URI_SUB_PATH_}" != "" ]; then
								PLUGIN_PATH_="${PLUGIN_PATH_}/${PLUGIN_URI_SUB_PATH_}"
							fi
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Using ensured plugin path: $PLUGIN_PATH_"
							local PLUGIN_MODULE_NAME_="_#_org.bashorigin_#_${PLUGIN_VERSION_}.sh"
							local PLUGIN_MODULE_PATH_="${PLUGIN_PATH_}/${PLUGIN_MODULE_NAME_}"
							if [ ! -e "$PLUGIN_MODULE_PATH_" ]; then
									echo >&2 "$BO_LOG_PREFIX""ERROR: Module '$PLUGIN_MODULE_NAME_' does not exist in plugin at path '$PLUGIN_MODULE_PATH_'!"

									# DEPRECATED
									PLUGIN_MODULE_NAME_="org.bashorigin-${PLUGIN_VERSION_}.sh"
									PLUGIN_MODULE_PATH_="${PLUGIN_PATH_}/${PLUGIN_MODULE_NAME_}"
									if [ ! -e "$PLUGIN_MODULE_PATH_" ]; then
											echo >&2 "$BO_LOG_PREFIX""ERROR: Module '$PLUGIN_MODULE_NAME_' does not exist in plugin at path '$PLUGIN_MODULE_PATH_'!"

											exit 1
									fi
							fi
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Load module from plugin: $PLUGIN_MODULE_PATH_"
							BO_sourceModule "$PLUGIN_MODULE_PATH_"
					elif [[ "${1}" == "@/"* ]]; then

							local PLUGIN_PATH_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[1]);
							' "${1}"`
							local PLUGIN_VERSION_=`BO_run_silent_node --eval '
									var uriParts = process.argv[1].match(/^@(.+)#(?:.+\/)?(.+)$/);
									process.stdout.write(uriParts[2]);
							' "${1}"`
							local PLUGIN_MODULE_PATH_="$PLUGIN_PATH_/_#_org.bashorigin_#_${PLUGIN_VERSION_}.sh"
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_requireModule] Load module from plugin: $PLUGIN_MODULE_PATH_"
							BO_sourceModule "$PLUGIN_MODULE_PATH_"
					else
							echo >&2 "ERROR: No actor found for URI: ${1}"
							exit 1
					fi
			elif [[ "${1}" == "/"* ]]; then

					local PLUGIN_MODULE_PATH_="${1}"
					BO_sourceModule "$PLUGIN_MODULE_PATH_"

			else
					echo >&2 "TODO: Alias-based includes that should resolve via mappings: $@"
					exit 1
			fi
			local func="$2"
			shift
			shift
			"$func" "$@"
	}

	function BO_sourceModule {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] args: $@"
			local _raw_source_path="$1"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] _raw_source_path: $_raw_source_path"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourceModule] pwd: $(pwd)"
			BO_compileModule "_raw_source_path" "${_raw_source_path}"
			BO_sourcePrototype "${_raw_source_path}" ${*:2}
	}

	function BO_sourcePrototype {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] args: $@"
		local _raw_source_path="$1"
		# Check if we have a module extension and if we do compile the module first.
		if [[ "${_raw_source_path}" == *".bo.sh" ]]; then
			BO_compileModule "_raw_source_path" "${_raw_source_path}"
		fi
		# Now load the module
		local _proto_source_path="${_raw_source_path}"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] _proto_source_path (1): ${_proto_source_path}"
		if [ -d "${_proto_source_path}" ]; then
			_proto_source_path="${_proto_source_path}/$(basename "${_proto_source_path}")"
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] _proto_source_path (2): ${_proto_source_path}"
		if [ ! -e "${_proto_source_path}" ]; then
			_proto_source_path="${_proto_source_path}.sh"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] _proto_source_path (3): ${_proto_source_path}"
			if [ ! -e "${_proto_source_path}" ]; then
				echo "$BO_LOG_PREFIX""ERROR: Cannot source '${_raw_source_path}' nor '${_proto_source_path}'. File not found!"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] DONE:1"
				return 1
			fi
		fi
		local __ON_INIT__BO_IS_SOURCING
		#echo "ENV: `( set -o posix ; set ) | less | grep BO_IS_SOURCING | while read line; do echo "___$line";done`"
		local __PREVIOUS_BO_IS_SOURCING="$BO_IS_SOURCING"
		local __PREVIOUS_BO_LOADED="$BO_LOADED"
		# TODO: Reset all relevant variables.
		BO_IS_SOURCING="1"
		BO_LOADED=1
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] ${_proto_source_path}"
		if [ "${*:2}" == "" ]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] Sourcing '${_proto_source_path}' using call method 1"
			# NOTE: If no arguments specified the source path becomes part of the arguments
			#       so we provide an empty one which fixes this for bash.
		    . "${_proto_source_path}" ""
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] done: Sourcing '${_proto_source_path}' using call method 1"
		else
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] Sourcing '${_proto_source_path}' using call method 2"
		    . "${_proto_source_path}" ${*:2}
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] done: Sourcing '${_proto_source_path}' using call method 2"
		fi
		# TODO: Restore all relevant variables.
		BO_IS_SOURCING="$__PREVIOUS_BO_IS_SOURCING"
		BO_LOADED="$__PREVIOUS_BO_LOADED"
		#while IFS= read -r -d $'\0' line; do
		#    export "$line"
		#done < <(bash -s <<< 'export VARNAME=something; env -0')
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_sourcePrototype] DONE"
	}

	function BO_followPointer {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "BO_followPointer($1, $2, $3)"

		_POINTER_RESULT_VAR="$1"
		_POINTER_LOOKUP_FILENAME="$3"
		_POINTER_RESOLVED="0"

		function checkPath {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "BO_followPointer:checkPath($1)"
			if [ -d "$1/$_POINTER_LOOKUP_FILENAME" ] || [ -h "$1/$_POINTER_LOOKUP_FILENAME" ]; then
				checkPath "$1/$_POINTER_LOOKUP_FILENAME"
			elif [ -e "$1/$_POINTER_LOOKUP_FILENAME" ]; then
				POINTER_VALUE=`cat $1/$_POINTER_LOOKUP_FILENAME`
				if [ "$POINTER_VALUE" == "." ]; then
					BO_realpath "$_POINTER_RESULT_VAR" "$1"
					_POINTER_RESOLVED="1"
				else
					checkPath "$1/$POINTER_VALUE"
				fi
			fi
		}
		checkPath "$2"
		if [ "$_POINTER_RESOLVED" == "0" ]; then
			echo >&2 "ERROR: Could not resolve pointer '$_POINTER_LOOKUP_FILENAME' for path '$2'"
			exit 1;
		fi
	}

	function BO_realpath {
		if BO_has "realpath"; then
			BO_setResult "$1" "$(realpath "$2")"
		else
			# @source http://stackoverflow.com/a/19512992/330439
			function abspath() {
			    # generate absolute path from relative path
			    # $1     : relative filename
			    # return : absolute path
			    if [ -d "$1" ]; then
			        # dir
			        (cd "$1"; pwd)
			    elif [ -f "$1" ]; then
			        # file
			        if [[ $1 == */* ]]; then
			            echo "$(cd "${1%/*}"; pwd)/${1##*/}"
			        else
			            echo "$(pwd)/$1"
			        fi
			    fi
			}
			BO_setResult "$1" "`abspath "$2"`"
		fi
	}

	# @source https://stackoverflow.com/a/12498485/330439
	function BO_relative {
		# both $1 and $2 are absolute paths beginning with /
		# returns relative path to $2/$target from $1/$source
		source=$1
		target=$2

		common_part=$source # for now
		result="" # for now

		while [[ "${target#$common_part}" == "${target}" ]]; do
			# no match, means that candidate common part is not correct
			# go up one level (reduce common part)
			common_part="$(dirname $common_part)"
			# and record that we went back, with correct / handling
			if [[ -z $result ]]; then
				result=".."
			else
				result="../$result"
			fi
		done

		if [[ $common_part == "/" ]]; then
			# special case for root (no common path)
			result="$result/"
		fi

		# since we now have identified the common part,
		# compute the non-common part
		forward_part="${target#$common_part}"

		# and now stick all parts together
		if [[ -n $result ]] && [[ -n $forward_part ]]; then
			result="$result$forward_part"
		elif [[ -n $forward_part ]]; then
			# extra slash removal
			result="${forward_part:1}"
		fi

		echo $result
	}

	function BO_isSourced {
		BO_setResult $1 "$__ON_INIT__BO_IS_SOURCING"
	}

	function BO_dedupe_PATH {
		# @source http://unix.stackexchange.com/a/149054
		export PATH="$(echo $PATH | perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, scalar <>))')"
	}

	function BO_strip_PATH {
		local WORK=:$PATH:
		local REMOVE="$1"
		WORK=${WORK/:$REMOVE:/:}
		WORK=${WORK%:}
		WORK=${WORK#:}
		export PATH=$WORK
	}

	function BO_prepend_PATH {
		export PATH="$1:$PATH"
	}

	# @see http://stackoverflow.com/a/29239609/330439
	function BO_if_os {
			local os="$1"
			if [ "$os" == "osx" ]; then
					os="darwin"
			fi
			[[ $OSTYPE == *$os* ]];
	}
	function BO_if_nix {
	    case "$OSTYPE" in
	        *linux*|*hurd*|*msys*|*cygwin*|*sua*|*interix*) sys="gnu";;
	        *bsd*|*darwin*) sys="bsd";;
	        *sunos*|*solaris*|*indiana*|*illumos*|*smartos*) sys="sun";;
	    esac
	    [[ "${sys}" == "$1" ]];
	}

	function BO_ensure_executable {
		if [[ ! -x "$1" ]]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Making path '$1' executable."
			chmod ug+x "$1"
		fi
	}

	function BO_exit_on_error {
		if [[ $? -ne 0 ]] ; then
			echo >&2 "FATAL ERROR while running '$*': $1"
		    exit 1
		fi
	}

	function BO_ensure_recent_node {
		if [[ $BO_ASSUME_NODE == 1 ]]; then
			return;
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] args: $@"
		# We just care that a version of NodeJS later than BO_VERSION_RECENT_NODE is installed.
		set +e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] Existing NodeJS version: $(node --version 2>&1 || true) ($(which node))"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] Desired NodeJS version: v5"

		if BO_has node && [ "$(BO_original_node_version)" -ge "$BO_VERSION_RECENT_NODE" ]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_recent_node] found"
			BO_ensure_bo_script_bin "$(dirname "$NVM_BIN")"
			return
		fi
		set -e
		BO_ensure_node "$@"		
	}

	function BO_ensure_node {
		if [[ $BO_ASSUME_NODE == 1 ]]; then
			return;
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] args: $@"
		set +e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Existing NodeJS version: $(node --version 2>&1 || true) ($(which node))"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Desired NodeJS version: v${BO_VERSION_NVM_NODE}"
		if [ "$(BO_original_node_version)" == "${BO_VERSION_NVM_NODE}" ]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE:1"
			BO_ensure_bo_script_bin "$(dirname "$NVM_BIN")"
			return
		fi
		set -e
		BO_sourceProfile
		set +e
		if [ "$(BO_original_node_version)" == "${BO_VERSION_NVM_NODE}" ]; then
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE:2"
			BO_ensure_bo_script_bin "$(dirname "$NVM_BIN")"
			return
		fi
		set -e
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] PATH: ${PATH}"
		if [ -e "/usr/bin" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] 'ls /usr/bin': $(ls /usr/bin | grep node)"
		fi
		BO_ensure_nvm
		function installAndUse {
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Installing and activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
			# TODO: Detect if error checking was enabled before disabeling
			# @see http://mywiki.wooledge.org/BashFAQ/105
			set +e
			nvm install "$BO_VERSION_NVM_NODE"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Deleting prefix for NodeJS version $BO_VERSION_NVM_NODE using nvm."
			nvm use --delete-prefix "${BO_VERSION_NVM_NODE}" > /dev/null 2>&1
			set -e
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Installing and activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
		}
		# If major version matches we do not activate.
		if ! BO_has node || [ "$(echo "$(node --version)" | perl -pe 's/^v(\d+)\..+$/$1/')" != "$BO_VERSION_NVM_NODE" ] ; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
			set +e
			nvm use --delete-prefix "${BO_VERSION_NVM_NODE}" > /dev/null 2>&1 || installAndUse
			set -e
			#result=$((nvm use --delete-prefix "${BO_VERSION_NVM_NODE}") 2>&1)
			#echo "RESULT: $result"
			#echo "CODE: $?"
			#if [[ ${result} == *"npm config delete prefix"* ]]; then
			#	cmd=$(echo "${result}" | grep "nvm use --delete-prefix ${BO_VERSION_NVM_NODE}" | perl -pe 's/^.*(nvm use --delete-prefix [^`]+)`.*$/$1/')
			#	if [ ! -z "${cmd}" ]; then
			#		$cmd
			#	    npm --prefix="" set prefix ""
			#		npm config set prefix ""
			#	fi
			#fi
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Activating NodeJS version $BO_VERSION_NVM_NODE using nvm."
		fi
		# TODO: Do not set default if already set.
		if [ "${1}" == "default" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] Setting NodeJS version $BO_VERSION_NVM_NODE as default."
				set +e
				if [ -z "$BO_VERBOSE" ]; then
						nvm alias default node > /dev/null 2>&1
				else
						nvm alias default node
				fi
				set -e
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] done: Setting NodeJS version $BO_VERSION_NVM_NODE as default."
   		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] which node: $(which node)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] ls -al $(which node): ls -al $(which node)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] node --version: $(node --version > /dev/null 2>&1 || true)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_node] DONE"
	}

	# DEPRECATED
	function BO_ensure_iojs {
# TODO: Check if 'node' command corresponds to our version
#		if BO_has "node"; then
#			return
#		fi
#		BO_sourceProfile
#		if BO_has "node"; then
#			return
#		fi
		BO_ensure_nvm
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Activating IO.JS version $BO_VERSION_NVM_IOJS using nvm."
		if [ -z "$BO_VERBOSE" ]; then
				nvm use "$BO_VERSION_NVM_IOJS" > /dev/null 2>&1
		else
				nvm use "$BO_VERSION_NVM_IOJS"
		fi
		if [[ $? -ne 0 ]]; then
				nvm install "$BO_VERSION_NVM_IOJS"
				nvm use "$BO_VERSION_NVM_IOJS"
		fi
	}

	function BO_ensure_nvm {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_nvm] args: $@"
		# @see https://github.com/creationix/nvm
		BO_ensureInSystemCache "NVM_PATH_" "github.com/creationix/nvm" "$BO_VERSION_NVM" "https://github.com/creationix/nvm/archive/v$BO_VERSION_NVM.tar.gz"
		pushd "$NVM_PATH_" > /dev/null
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "Loading nvm from '$NVM_PATH_/nvm.sh'"
			export NVM_EXEC_PATH="$NVM_PATH_/nvm-exec"
			set +e
			if [ -z "$BO_VERBOSE" ]; then
					. "$NVM_PATH_/nvm.sh" >/dev/null 2>&1
			else
					. "$NVM_PATH_/nvm.sh"
			fi
			set -e
		popd > /dev/null
		BO_ensure_bo_script_bin "$(dirname "$NVM_BIN")"
		export NVM_SH="$NVM_PATH_/nvm.sh"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensure_nvm] DONE"
#		curl \
#		    -H "Pragma: no-cache, must-revalidate" \
#		    -H "Cache-Control: no-cache, must revalidate" \
#		    "https://raw.githubusercontent.com/creationix/nvm/v$BO_VERSION_NVM/install.sh" \
#		    | sh
#		BO_sourceProfile
	}

	function BO_link_node {
		if [[ $BO_ASSUME_NODE == 1 ]]; then
			return;
		fi		
		rm -f "$1/node" > /dev/null 2>&1 || true
		BO_ensure_node
		ln -s "$NVM_BIN/node" "$1/node"
	}

	function BO_link_npm {
		if [[ $BO_ASSUME_NODE == 1 ]]; then
			return;
		fi
		rm -f "$1/npm" > /dev/null 2>&1 || true
		BO_ensure_node
		ln -s "$NVM_BIN/npm" "$1/npm"
	}

	function BO_run_silent_node {
		local __OLD_BO_VERBOSE="${BO_VERBOSE}"
		local __OLD_VERBOSE="${VERBOSE}"
                BO_SILENT=1
		BO_VERBOSE=
		VERBOSE=
		BO_run_recent_node "$@"
		local exitCode=$?
		BO_VERBOSE="${__OLD_BO_VERBOSE}"
		VERBOSE="${__OLD_VERBOSE}"
                BO_SILENT=
		return $exitCode;
	}

	function BO_run_recent_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] args: $@"
		if [[ $BO_ASSUME_NODE != 1 ]]; then
			BO_ensure_recent_node
		fi		
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] NodeJS version: $(node --version 2>&1)"
		node "$@"
		local exitCode=$?
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_recent_node] END"
		return $exitCode;
	}

	function BO_run_node {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] args: $@"
		if [[ $BO_ASSUME_NODE != 1 ]]; then
			BO_ensure_node
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] NodeJS version: $(node --version 2>&1)"
		node "$@"
		local exitCode=$?
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] END"
		return $exitCode;
	}

	# DEPRECATED
	function BO_run_iojs {
		BO_ensure_iojs
		node $@
	}

	function BO_run_npm {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] args: $@"
		if [[ $BO_ASSUME_NODE != 1 ]]; then
			BO_ensure_node
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_node] NodeJS version: $(node --version)"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] npm version: $(npm --version)"
		local currentNPM=`printenv | grep '^npm_'`
		# TODO: Reset all 'npm_*' variables.
		export npm_config_argv=
		export npm_config_dev=
		npm $@ 1>&2
		local exitCode=$?
#		eval "$currentNPM"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_run_npm] END"
		return $exitCode;
	}

	function BO_ensure_smi {
		BO_ensure_node
		local CACHED_PATH
		BO_isInSystemCache CACHED_PATH "github.com/sourcemint/smi" "$BO_VERSION_SMI_CLI"
		if [ "$CACHED_PATH" == "" ]; then
			# TODO: Ask user before installing.
			echo >&2 "$BO_LOG_PREFIX""Installing smi ..."
			BO_ensureInSystemCache "DOWNLOADED_PATH" "github.com/sourcemint/smi" "$BO_VERSION_SMI_CLI" "https://github.com/sourcemint/smi/archive/v$BO_VERSION_SMI_CLI.tar.gz"
			# TODO: Install into "$DOWNLOADED_PATH.`now`" and only rename on success.
			# TODO: Stop this from also being written to stdout.
			pushd "$DOWNLOADED_PATH" > /dev/null
				BO_run_npm install --production
			popd > /dev/null
			echo >&2 "$BO_LOG_PREFIX""... smi installed"
			CACHED_PATH="$DOWNLOADED_PATH"
		fi
		BO_setResult $1 "$CACHED_PATH"
	}

	function BO_link_smi {
		rm -f "$1/smi" > /dev/null 2>&1 || true
		local SMI_CACHE_PATH_
		BO_ensure_smi SMI_CACHE_PATH_
		ln -s "$SMI_CACHE_PATH_/bin/smi" "$1/smi"
	}

	function BO_run_smi {
		local SMI_CACHE_PATH_
		BO_ensure_smi SMI_CACHE_PATH_
		"$SMI_CACHE_PATH_/bin/smi" $@
	}

	function BO_getLatestTagForURI {
		local ORG_REPO=`echo "$1" | perl -wnE 'say for /^(?:[^\/]+\/)?(.+)$/g'`

		local __latestVersionLookupUri="https://api.github.com/repos/$ORG_REPO/tags"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Fetching latest version for 'github.com/$ORG_REPO' from '$__latestVersionLookupUri'"
		set +e
		versions=`curl -s "$__latestVersionLookupUri" | grep '"name": "v'`
		set -e
		# TODO: If repository not found emit *insight* formatted message to indicate this so that
		#       tooling can auto-provision repository and then download accordingly.
		#       We can add a rest call here that can hold execution until the repository is
		#       provisioned and we can try again.
		if [ "$versions" == "" ]; then
			echo "master"
		else
			latestTag=`echo "$versions" | head -n 1 | perl -pe 's/^.+?"(v?[^"]+)",$/$1/'`
			if [ "$latestTag" == "" ]; then
				echo >&2 "$BO_LOG_PREFIX""ERROR: Latest tag could not be determined for uri '$1'!"
				exit 1
			fi
			echo "$latestTag"
		fi
	}

	# TODO: Use require("bash.origin").resolve and if no path found derive one based on BO_SYSTEM_CACHE_DIR and if not set BO_GLOBAL_SYSTEM_CACHE_DIR.
	function BO_systemCachePath {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] args: $@"
		local URI_DIRNAME_=`echo "$2" | sed 's/\//~/g'`
		local URI_REPONAME_=`echo "$URI_DIRNAME_" | perl -pe 's/.+~([^~]+)$/$1/'`
		local URI_MAJOR_VERSION_=`echo "$3" | perl -wnE 'say for /^\d+/g'`

		if [ ! -z "$BO_FORCE_SYSTEM_CACHE_DIR" ]; then
			local DOWNLOAD_PATH_="$BO_FORCE_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/snapshot/$3"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (1): $DOWNLOAD_PATH_"
			if [ -d "$DOWNLOAD_PATH_" ]; then
				BO_setResult $1 "$DOWNLOAD_PATH_"
			else
				local DOWNLOAD_DIR_="$(dirname "$DOWNLOAD_PATH_")"
				if [ "$4" != "nocreate" ]; then
					if [ ! -d "$DOWNLOAD_DIR_" ]; then
						[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Creating directory: $DOWNLOAD_DIR_"
						mkdir -p "$DOWNLOAD_DIR_"
					fi
				fi
				BO_setResult $1 "$DOWNLOAD_PATH_"
			fi
		else
			# TODO: Loop over multiple paths separated by ":" - http://stackoverflow.com/a/918931/330439
			local DOWNLOAD_PATH_="$BO_SOURCE_DIRPATHS/$URI_DIRNAME_"
			if [ ! -z "${BO_SOURCE_DIRPATHS}" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (0): $DOWNLOAD_PATH_"
				if [ -d "$DOWNLOAD_PATH_" ]; then
					BO_setResult $1 "$DOWNLOAD_PATH_"
					return
				fi
			fi
			DOWNLOAD_PATH_="$(pwd)/node_modules/$URI_DIRNAME_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (1): $DOWNLOAD_PATH_"
			if [ -d "$DOWNLOAD_PATH_" ]; then
				BO_setResult $1 "$DOWNLOAD_PATH_"
			else
				DOWNLOAD_PATH_="$(pwd)/node_modules/$URI_REPONAME_"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (2): $DOWNLOAD_PATH_"
				if [ -d "$DOWNLOAD_PATH_" ]; then
					BO_setResult $1 "$DOWNLOAD_PATH_"
				else
					DOWNLOAD_PATH_="$BO_DIR/node_modules/$URI_DIRNAME_"
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (3): $DOWNLOAD_PATH_"
					if [ -d "$DOWNLOAD_PATH_" ] && [ -e "$DOWNLOAD_PATH_/package.json" ]; then
						BO_setResult $1 "$DOWNLOAD_PATH_"
					else
						DOWNLOAD_PATH_="$BO_DIR/node_modules/$URI_REPONAME_"
						[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (4): $DOWNLOAD_PATH_"
						if [ -d "$DOWNLOAD_PATH_" ] && [ -e "$DOWNLOAD_PATH_/package.json" ]; then
							BO_setResult $1 "$DOWNLOAD_PATH_"
						else
							DOWNLOAD_PATH_="$BO_DIR/../$URI_DIRNAME_"
							[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (5): $DOWNLOAD_PATH_"
							if [ -d "$DOWNLOAD_PATH_" ] && [ -e "$DOWNLOAD_PATH_/package.json" ]; then
								BO_setResult $1 "$DOWNLOAD_PATH_"
							else
								DOWNLOAD_PATH_="$BO_DIR/../$URI_REPONAME_"
								[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (6): $DOWNLOAD_PATH_"
								if [ -d "$DOWNLOAD_PATH_" ] && [ -e "$DOWNLOAD_PATH_/package.json" ]; then
									BO_setResult $1 "$DOWNLOAD_PATH_"
								else
									DOWNLOAD_PATH_="$BO_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/installed/master"
									[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (7): $DOWNLOAD_PATH_"
									if [ -d "$DOWNLOAD_PATH_" ]; then
										BO_setResult $1 "$DOWNLOAD_PATH_"
									else
										DOWNLOAD_PATH_="$BO_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/snapshot/$3"
										[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Check path (8): $DOWNLOAD_PATH_"
										local DOWNLOAD_DIR_="$( dirname "$DOWNLOAD_PATH_")"
										if [ "$4" != "nocreate" ]; then
											if [ ! -d "$DOWNLOAD_DIR_" ]; then
												[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_systemCachePath] Creating directory: $DOWNLOAD_DIR_"
												mkdir -p "$DOWNLOAD_DIR_"
											fi
										fi
										BO_setResult $1 "$DOWNLOAD_PATH_"
									fi
								fi
							fi
						fi
					fi
				fi
			fi
		fi
	}

	function BO_globalSystemCachePath {
		local URI_DIRNAME_=`echo "$2" | sed 's/\//~/g'`
		local URI_MAJOR_VERSION_=`echo "$3" | perl -wnE 'say for /^\d+/g'`
		local DOWNLOAD_PATH_="$BO_GLOBAL_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/installed/master"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_globalSystemCachePath] Check path (1): $DOWNLOAD_PATH_"
		if [ -d "$DOWNLOAD_PATH_" ]; then
			BO_setResult $1 "$DOWNLOAD_PATH_"
		else
			DOWNLOAD_PATH_="$BO_GLOBAL_SYSTEM_CACHE_DIR/$URI_DIRNAME_~$URI_MAJOR_VERSION_/source/snapshot/$3"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_globalSystemCachePath] Check path (2): $DOWNLOAD_PATH_"
		  	local DOWNLOAD_DIR_="$( dirname "$DOWNLOAD_PATH_")"
		  	if [ "$4" != "nocreate" ]; then
			  	if [ ! -d "$DOWNLOAD_DIR_" ]; then
					mkdir -p "$DOWNLOAD_DIR_"
			  	fi
			fi
			BO_setResult $1 "$DOWNLOAD_PATH_"
		fi
	}

	function BO_isInSystemCache {
		local CACHE_PATH__
		BO_systemCachePath CACHE_PATH__ "$2" "$3" "nocreate"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_isInSystemCache] for uri '$2' at revision '$3': $CACHE_PATH__"
		if [ -e "$CACHE_PATH__" ]; then
			BO_setResult $1 "$CACHE_PATH__"
		else
			BO_setResult $1 ""
		fi
	}

	function BO_isInGlobalSystemCachePath {
		local CACHE_PATH__
		BO_globalSystemCachePath CACHE_PATH__ "$2" "$3" "nocreate"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_isInGlobalSystemCachePath] for uri '$2' at revision '$3': $CACHE_PATH__"
		if [ -e "$CACHE_PATH__" ]; then
			BO_setResult $1 "$CACHE_PATH__"
		else
			BO_setResult $1 ""
		fi
	}

	function BO_downloadUrlTo {
	  	function download {
			if BO_has "curl"; then
				curl \
				    -L \
				    -H "Pragma: no-cache, must-revalidate" \
				    -H "Cache-Control: no-cache, must revalidate" \
				    $*
			elif BO_has "wget"; then
				# Emulate curl with wget
				# @source https://github.com/creationix/nvm/blob/master/install.sh
				# TODO: Add nocache flag.
				local ARGS=$(echo "$*" | command sed -e 's/--progress-bar /--progress=bar /' \
					-e 's/-L //' \
					-e 's/-I /--server-response /' \
					-e 's/-s /-q /' \
					-e 's/-o /-O /' \
					-e 's/-C - /-c /')
				wget $ARGS
			fi
	  	}

		download -s "$1" -o "$2" || {
			echo >&2 "$BO_LOG_PREFIX""Failed to download '$1' to '$2'"
			return 1
		}
	}

	function BO_downloadToSystemCache {
		if [[ $BO_ALLOW_DOWNLOADS != 1 ]]; then
			BO_exit_error "Cannot download '$4' due to 'BO_ALLOW_DOWNLOADS!=1'!"
		fi
		local DOWNLOAD_PATH__
		BO_systemCachePath DOWNLOAD_PATH__ "$2" "$3"
		local DOWNLOAD_URL_="$4"
		local DOWNLOAD_FILE_EXTENSION_=`echo "$DOWNLOAD_URL_" | perl -wnE 'say for /\.([^\.]+)$/g'`
		# TODO: Append '?t=$(date +%s)' to URL to force download?
	  	local ARCHIVE_DOWNLOAD_PATH__
	  	if [ "$DOWNLOAD_FILE_EXTENSION_" == "gz" ]; then
	  		# TODO: Don't assume '.tar.'. Check to make sure.
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.tar.gz"
	  	elif [ "$DOWNLOAD_FILE_EXTENSION_" == "zip" ]; then
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.zip"
	  	elif [ "$DOWNLOAD_FILE_EXTENSION_" == "phar" ]; then
	  		ARCHIVE_DOWNLOAD_PATH__="$DOWNLOAD_PATH__.phar"
	  	else
			echo >&2 "$BO_LOG_PREFIX""ERROR: Derived file extension '$DOWNLOAD_FILE_EXTENSION_' from url '$DOWNLOAD_URL_' not supported!"
			return 1
	  	fi
	  	if [ -e "$ARCHIVE_DOWNLOAD_PATH__" ]; then
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Download path '$ARCHIVE_DOWNLOAD_PATH__' exists. Removing."
			rm -Rf "$ARCHIVE_DOWNLOAD_PATH__"
	  	fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Downloading '$DOWNLOAD_URL_' to '$ARCHIVE_DOWNLOAD_PATH__'"
		
		BO_downloadUrlTo "$DOWNLOAD_URL_" "$ARCHIVE_DOWNLOAD_PATH__" || {
			echo >&2 "$BO_LOG_PREFIX""Failed to download '$ARCHIVE_DOWNLOAD_PATH__'"
			return 1
		}
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "${BO_LOG_PREFIX}Extracting '$ARCHIVE_DOWNLOAD_PATH__' to '$DOWNLOAD_PATH__'"
		BO_ensureExtracted "EXTRACTED_PATH__" "$ARCHIVE_DOWNLOAD_PATH__" || {
			echo >&2 "$BO_LOG_PREFIX""Failed to extract '$ARCHIVE_DOWNLOAD_PATH__'"
			return 1
		}
		if [ "$EXTRACTED_PATH__" != "$DOWNLOAD_PATH__" ]; then
			echo >&2 "$BO_LOG_PREFIX""ERROR: Actual extracted path '$EXTRACTED_PATH__' does not match expected path '$DOWNLOAD_PATH__'!"
			return 1
		fi
		BO_setResult $1 "$DOWNLOAD_PATH__"
	}

	function BO_ensureInSystemCache {
		local DOWNLOAD_PATH___
		BO_systemCachePath DOWNLOAD_PATH___ "$2" "$3"
		if [ ! -e "$DOWNLOAD_PATH___" ]; then
			BO_downloadToSystemCache DOWNLOAD_PATH___ "$2" "$3" "$4"
		fi
		BO_setResult $1 "$DOWNLOAD_PATH___"
	}

	function BO_ensureExtracted {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] args: $@"
		local DOWNLOADED_PATH_="$2"
		if [[ "$DOWNLOADED_PATH_" == *".tar.gz" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.tar\.gz$//g'`
			if [ ! -d "$EXTRACTED_PATH_" ]; then
				pushd "$(dirname $DOWNLOADED_PATH_)" > /dev/null
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
					mkdir "__$(basename $EXTRACTED_PATH_)"
					tar -xzf "$(basename $DOWNLOADED_PATH_)" -C "__$(basename $EXTRACTED_PATH_)"
					local RESOLVED_PATH=("$(pwd)"/__"$(basename $EXTRACTED_PATH_)"/*/*)
					mv -f "$(dirname "$RESOLVED_PATH")" "$(basename $EXTRACTED_PATH_)"
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
				popd > /dev/null
			fi
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:1"
			return 0
		elif [[ "$DOWNLOADED_PATH_" == *".zip" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.zip$//g'`
			if [ ! -d "$EXTRACTED_PATH_" ]; then
				pushd "$(dirname $DOWNLOADED_PATH_)" > /dev/null
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
					mkdir "__$(basename $EXTRACTED_PATH_)"
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] Extract '$(basename $DOWNLOADED_PATH_)' to '__$(basename $EXTRACTED_PATH_)' (pwd: '$(pwd)')"
					if ! which unzip > /dev/null; then
							echo >&2 "$BO_LOG_PREFIX""ERROR: You must have 'unzip' installed!"
							return 1
					fi
					unzip -q -d "__$(basename $EXTRACTED_PATH_)" "$(basename $DOWNLOADED_PATH_)"
					local RESOLVED_PATH=("__$(basename $EXTRACTED_PATH_)"/*)
					if [ -d "$RESOLVED_PATH" ]; then
						mv -f "$RESOLVED_PATH" "$(basename $EXTRACTED_PATH_)"
					else
						mkdir "$(basename $EXTRACTED_PATH_)"
						mv -f "$RESOLVED_PATH" "$(basename $EXTRACTED_PATH_)/$(basename $RESOLVED_PATH)"
					fi
					rm -Rf "__$(basename $EXTRACTED_PATH_)" > /dev/null || true
				popd > /dev/null
			fi
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:2"
			return 0
		elif [[ "$DOWNLOADED_PATH_" == *".phar" ]]; then
			local EXTRACTED_PATH_=`echo "$DOWNLOADED_PATH_" | sed 's/\.phar$//g'`
			ln -s "$(basename "$DOWNLOADED_PATH_")" "$EXTRACTED_PATH_"
			# No need to extract.
			BO_setResult $1 "$EXTRACTED_PATH_"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:3"
			return 0
		else
			echo >&2 "$BO_LOG_PREFIX""ERROR: Unable to extract path '$DOWNLOADED_PATH_'!"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensureExtracted] END:4"
			return 1
		fi
	}

	function BO_ensurePlugin {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] args: $@"
		local PLUGIN_NAME=`echo "$2" | perl -wnE 'say for /^(?:.+\/)?([^@\/]+)@?/g'`
		local PLUGIN_ID=`echo "$2" | sed 's/\//~/g'`
		local PLUGIN_VERSION=`echo "$2" | perl -wnE 'say for /@[v]{1}([^@]+)$/g'`
		local PLUGIN_ORG="bash-origin"
		if [[ "$PLUGIN_ID" == "github.com~"* ]] || [[ "$PLUGIN_ID" == "com.github~"* ]]; then
			PLUGIN_ORG=`echo "$PLUGIN_ID" | perl -wnE 'say for /^.+~([^~]+)~/g'`
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_NAME: $PLUGIN_NAME"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_ID: $PLUGIN_ID"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_ORG: $PLUGIN_ORG"
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] PLUGIN_VERSION: $PLUGIN_VERSION"
		if [ ! -z "${PLUGIN_VERSION}" ]; then
				local PLUGIN_URL="https://github.com/$PLUGIN_ORG/$PLUGIN_NAME/archive/v$PLUGIN_VERSION.zip"
		else
				local PLUGIN_VERSION=`echo "$2" | perl -wnE 'say for /@([^@]+)$/g'`
				local PLUGIN_URL="https://github.com/$PLUGIN_ORG/$PLUGIN_NAME/archive/v$PLUGIN_VERSION.zip"
		fi
		local PLUGIN_PATH=""
		if [ "$BO_SOURCE_DIRPATHS" != "" ] && [[ "$_BO_ensurePlugin__onlyDownloadedLocations" -ne 1 ]]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Look for plugin in '$BO_SOURCE_DIRPATHS'"
				if [ ! -z "$BO_SOURCE_DIRPATHS" ]; then
					# TODO: Loop over multiple paths separated by ":" - http://stackoverflow.com/a/918931/330439
					if [ -e "$BO_SOURCE_DIRPATHS/$PLUGIN_NAME" ]; then
							PLUGIN_PATH="$BO_SOURCE_DIRPATHS/$PLUGIN_NAME"
					elif [ -e "$BO_SOURCE_DIRPATHS/$PLUGIN_ID" ]; then
							PLUGIN_PATH="$BO_SOURCE_DIRPATHS/$PLUGIN_ID"
					fi
					if [ "$PLUGIN_PATH" == "" ]; then
						if [ -e "$BO_SOURCE_DIRPATHS/github.com~$PLUGIN_ORG~$PLUGIN_NAME" ]; then
							PLUGIN_PATH="$BO_SOURCE_DIRPATHS/github.com~$PLUGIN_ORG~$PLUGIN_NAME"
						fi
					fi
				fi
		fi
		if [ "$PLUGIN_PATH" == "" ] && [ "$PLUGIN_VERSION" == "" ]; then
				local __latestVersionLookupUri="https://api.github.com/repos/$PLUGIN_ORG/$PLUGIN_NAME/tags"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Fetching latest version for 'github.com/$PLUGIN_ORG/$PLUGIN_NAME' from '$__latestVersionLookupUri'"
				set +e
				versions=`curl -s "$__latestVersionLookupUri" | grep '"name": "v'`
				set -e
				# TODO: If repository not found emit *insight* formatted message to indicate this so that
				#       tooling can auto-provision repository and then download accordingly.
				#       We can add a rest call here that can hold execution until the repository is
				#       provisioned and we can try again.
				if [ "$versions" == "" ]; then
						PLUGIN_VERSION="master"
						PLUGIN_URL="https://github.com/$PLUGIN_ORG/$PLUGIN_NAME/archive/$PLUGIN_VERSION.zip"
				else
						latestTag=`echo "$versions" | head -n 1 | perl -pe 's/^.+?"(v?[^"]+)",$/$1/'`
						if [ "$latestTag" == "" ]; then
								echo >&2 "$BO_LOG_PREFIX""ERROR: Latest tag could not be determined for plugin name '$PLUGIN_NAME'!"
								exit 1
						fi
						PLUGIN_VERSION="$latestTag"
						PLUGIN_URL="https://github.com/$PLUGIN_ORG/$PLUGIN_NAME/archive/$PLUGIN_VERSION.zip"
				fi
		fi
		if [ "$PLUGIN_PATH" == "" ]; then
			BO_isInSystemCache PLUGIN_PATH "github.com/$PLUGIN_ORG/$PLUGIN_NAME" "$PLUGIN_VERSION"
			if [ "$PLUGIN_PATH" == "" ]; then
				# TODO: Ask user before installing.
				[ -z "$BO_VERBOSE" ] || echo >&2 "$BO_LOG_PREFIX""Installing plugin '$PLUGIN_NAME' at version '$PLUGIN_VERSION'"
				BO_ensureInSystemCache PLUGIN_PATH "github.com/$PLUGIN_ORG/$PLUGIN_NAME" "$PLUGIN_VERSION" "$PLUGIN_URL"
			fi
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Found plugin path: $PLUGIN_PATH"

		# Install dependencies
		# TODO: Use 'smi' to install with better package type detection.
		if [ -e "$PLUGIN_PATH/package.json" ]; then
			if [ ! -e "$PLUGIN_PATH/.installed" ] && [ ! -e "$PLUGIN_PATH/.installed.production" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Installing dependencies for plugin path: $PLUGIN_PATH"

				if [[ $BO_ALLOW_INSTALLS != 1 ]]; then
					BO_exit_error "Cannot install '$PLUGIN_PATH' (triggered by missing '.installed') due to 'BO_ALLOW_INSTALLS!=1'!"
				fi

				pushd "$PLUGIN_PATH" > /dev/null
					echo "TEST_MATCH_IGNORE>>>"

					BO_run_npm install --production

					echo "<<<TEST_MATCH_IGNORE"
					touch ".installed"
				popd > /dev/null
			fi
		fi

		BO_setResult $1 "$PLUGIN_PATH/$PLUGIN_NAME"
	}

	function BO_callDownloadedPlugin {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callDownloadedPlugin] args: $@"
		_BO_ensurePlugin__onlyDownloadedLocations=1
		BO_callPlugin "$@"
	}

	function BO_callPlugin {
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] args: $@"
		local PLUGIN_PATH_
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] BO_SYSTEM_CACHE_DIR: $BO_SYSTEM_CACHE_DIR"
		if [[ "$_BO_ensurePlugin__onlyDownloadedLocations" -ne 1 ]] && [ -e "$BO_SYSTEM_CACHE_DIR/$1" ]; then
			PLUGIN_PATH_="$BO_SYSTEM_CACHE_DIR/$1"
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] Using BO_SYSTEM_CACHE_DIR based path: $PLUGIN_PATH_"
		else
			if [[ "$1" == "/"* ]]; then
				PLUGIN_PATH_="$1"
				BO_log "$VERBOSE" "[BO_callPlugin] Using absolute path: $PLUGIN_PATH_"
			else
				BO_ensurePlugin "PLUGIN_PATH_" "$1"
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_callPlugin] Using ensured plugin path: $PLUGIN_PATH_"
			fi
		fi
		[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "[BO_ensurePlugin] Call plugin: $PLUGIN_PATH_"
		BO_sourcePrototype "$PLUGIN_PATH_"
		local func="$2"
		shift
		shift
		"$func" "$@"
	}

	function BO_trim_file_end {
		# Remove training space to ensure comparisons work across OSes
		# @see http://unix.stackexchange.com/a/81689/92833
		a=$(<$1); printf '%s\n' "$a" > $1
	}


	###############################
	# Act
	###############################

	function BO_self_install {
		BO_checkVerbose "VERBOSE" "$@"

		# TODO: If we are installed in '~/.bash.origin.cache/lib/..../bacj.origin' we need to
		#       link '~/.bash.origin' instead of copying it.

		# TODO: Introduce external variable to set target install path
		local installTargetPath="$ORIGINAL_BO_ROOT_SCRIPT_PATH"
		if [ -z "$installTargetPath" ] || [ "$installTargetPath" == "$BO_ROOT_SCRIPT_PATH" ]; then
				# Target path not set so we use the default one
				BO_ensure_env_HOME "Use default '$BO_PREFIX_DIR/bin/bash.origin'"
				installTargetPath="$BO_PREFIX_DIR/bin/bash.origin"
		elif [ ! -e "$installTargetPath" ]; then
			# We may have an old 'BO_ROOT_SCRIPT_PATH' set that no longer exists.
			# We assue that is the case if the parent path no longer exists.
			# If you don't want the path to be reset make sure the parent path exists!
			if [ ! -e "$(dirname $installTargetPath)" ]; then
				BO_ensure_env_HOME "Use default '$BO_PREFIX_DIR/bin/bash.origin'"
				installTargetPath="$BO_PREFIX_DIR/bin/bash.origin"
			fi
		fi
		if [ "$installTargetPath" == "$1" ]; then
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Skip copy of '$1' to '$installTargetPath' as path is the same."
		else
				if [ "$2" == "-f" ]; then
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Removing '$installTargetPath' due to forced-install (BO install -f)"
					rm -f "$installTargetPath" || true
				fi
				if [ ! -e "$installTargetPath" ]; then
					if [ ! -e "$(dirname "$installTargetPath")" ]; then
						mkdir -p "$installTargetPath"
					fi
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Copying '$1' to '$installTargetPath'"
					cp -f "$1" "$installTargetPath"
				else
					# TODO: Copy if version has changed.
					[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Skip copy of '$1' as '$installTargetPath' already exists."
				fi
				[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""bash.origin installed!"
		fi
		# NOTE: We do not install nvm by default.
		#BO_ensure_nvm
	}

	function BO_self_update {
echo >&2 "TODO: BO_self_update"
exit 1
		local BASH_ORIGIN_PATH
		local FOUND_PREVIOUS_CACHE="0"
	  	if [ -d "$BO_SYSTEM_CACHE_DIR" ]; then
	  		FOUND_PREVIOUS_CACHE="1"
	  	fi
		BO_downloadToSystemCache BASH_ORIGIN_PATH "github.com/bash-origin/bash.origin" "master" "bash.origin" "$BO_ROOT_SOURCE_URL?t=$(date +%s)"
		BO_self_install "$BASH_ORIGIN_PATH" -f
		if [ "$FOUND_PREVIOUS_CACHE" == "0" ]; then
			rm -Rf "$BO_SYSTEM_CACHE_DIR"
		fi
		echo "$BO_LOG_PREFIX""bash.origin updated!"
	}


	function BO_init_workspace {
		newDir="$(pwd)/$1"

		echo
		read -p "$(BO_cecho "Initialize bash.origin workspace at '$newDir'? [y|n]: " WHITE BOLD)" -n 1 -r
		echo

		if [[ $REPLY =~ ^[Yy]$ ]]; then

			if [ -e "$newDir" ]; then
				BO_exit_error "Directory '$newDir' already exists!"
			fi
			# TODO: Check with network to see if name is available.
			mkdir -p "$newDir"
			pushd "$newDir" > /dev/null
				git init
				bash.origin.test examples --init
				npm test
			popd > /dev/null
			BO_cecho "New bash.origin based project successfully created at: $newDir" GREEN
			#echo >&2 "ACTION: To publish run: $(BO_cecho "bash.origin $1 --publish" MAGENTA)"
			exit 0

		else
			echo >&2 "Aborted!"
			exit 1
		fi
	}


	# Bash Origin Bin invocation
	if [ "$1" == "BOB" ]; then

        if BO_has_arg "--init" "$@"; then

			BO_parse_args "ARGS" "$@"
			BO_init_workspace "$ARGS_2"

		elif [ "$2" == "BOE" ]; then
			# When used via '. bash.origin BOE'
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Sourced 'bash.origin' environment. (args: $@)"
		else
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""Loaded 'bash.origin' environment. (args: $@)"
			func="$2"
			shift
			shift
			[ -z "$BO_VERBOSE" ] || BO_log "$BO_VERBOSE" "$BO_LOG_PREFIX""func: $func"
			. "$func" "$@"
		fi

	# Bash Origin Script invocation
  	elif [ "$1" == "BOS" ]; then

		local ___old_BO_OPTIMIZED="$_BO_OPTIMIZED"
		if [ "$3" == "-c" ]; then
				_BO_OPTIMIZED=0
		fi
		# Load provided URI as bash.origin.script module
		BO_requireModule "${2}" as "module" ${*:3}
		_BO_OPTIMIZED="$___old_BO_OPTIMIZED"

	# Bash Origin Internal Util invocation
	elif [ "$1" == "BO" ]; then

		if [ ! -z "$VERBOSE" ]; then
				export BO_VERBOSE=1
		fi
		## Usage: `bash.origin BO install [-f]
		if [ "$2" == "install" ]; then
			# TODO: Instead of using '$BO_DIR' use '$BO_FILE' which should
			#       point to this file.
			if [ -e "$BO_DIR/bash.origin" ]; then
				BO_self_install "$BO_DIR/bash.origin" "$3"
			elif [ -e "$BO_DIR/.bash.origin" ]; then
				BO_self_install "$BO_DIR/.bash.origin" "$3"
			else
				echo >&2 "[bash.origin] ERROR: Could not locate path to source!"
				exit 1
			fi
			exit 0
		elif [ "$2" == "update" ]; then
			BO_self_update
			exit 0
		fi
		echo >&2 "$BO_LOG_PREFIX""ERROR: Unknown BO command '$2'!"
		exit 1

	elif [ "$BO" == "install" ]; then

		BO_self_update
		BO=""
		exit 0
	fi
}
init $@
